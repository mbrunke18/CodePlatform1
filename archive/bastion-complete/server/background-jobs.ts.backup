import { Queue, Worker } from 'bullmq';
import IORedis from 'ioredis';
import pino from 'pino';
import { nlqService } from './nlq-service';
import { storage } from './storage';

const logger = pino({ name: 'background-jobs' });

// Redis connection for BullMQ
const redis = new IORedis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  maxRetriesPerRequest: 3,
  enableReadyCheck: false,
  lazyConnect: true
});

// Job queue definitions
export const analysisQueue = new Queue('analysis', { connection: redis });
export const reportsQueue = new Queue('reports', { connection: redis });
export const alertsQueue = new Queue('alerts', { connection: redis });

export interface AnalysisJobData {
  type: 'pulse_analysis' | 'risk_assessment' | 'opportunity_detection' | 'performance_trends';
  organizationId: string;
  parameters?: Record<string, any>;
  scheduledBy?: string;
}

export interface ReportJobData {
  type: 'executive_summary' | 'performance_dashboard' | 'scenario_analysis' | 'competitive_intelligence';
  organizationId: string;
  recipientEmails: string[];
  format: 'pdf' | 'html' | 'json';
  templateId?: string;
}

export interface AlertJobData {
  type: 'risk_threshold' | 'performance_anomaly' | 'opportunity_alert' | 'critical_metric';
  organizationId: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  actionRequired?: boolean;
  recipients: string[];
}

export class BackgroundJobService {
  private static instance: BackgroundJobService;
  private analysisWorker?: Worker;
  private reportsWorker?: Worker;
  private alertsWorker?: Worker;

  public static getInstance(): BackgroundJobService {
    if (!BackgroundJobService.instance) {
      BackgroundJobService.instance = new BackgroundJobService();
    }
    return BackgroundJobService.instance;
  }

  /**
   * Initialize all background workers
   */
  async initialize(): Promise<void> {
    try {
      await this.setupAnalysisWorker();
      await this.setupReportsWorker();
      await this.setupAlertsWorker();
      await this.scheduleRecurringJobs();
      
      logger.info('Background job service initialized successfully');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      logger.error({ error: errorMessage }, 'Failed to initialize background job service');
      throw error;
    }
  }

  /**
   * Setup analysis worker for proactive insights
   */
  private async setupAnalysisWorker(): Promise<void> {
    this.analysisWorker = new Worker(
      'analysis',
      async (job) => {
        const { type, organizationId, parameters } = job.data as AnalysisJobData;
        
        try {
          logger.info({ jobId: job.id, type, organizationId }, 'Processing analysis job');
          
          switch (type) {
            case 'pulse_analysis':
              return await this.processPulseAnalysis(organizationId, parameters);
            case 'risk_assessment':
              return await this.processRiskAssessment(organizationId, parameters);
            case 'opportunity_detection':
              return await this.processOpportunityDetection(organizationId, parameters);
            case 'performance_trends':
              return await this.processPerformanceTrends(organizationId, parameters);
            default:
              throw new Error(`Unknown analysis type: ${type}`);
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Unknown error';
          logger.error({ jobId: job.id, error: errorMessage }, 'Analysis job failed');
          throw error;
        }
      },
      {
        connection: redis,
        concurrency: 5,
        removeOnComplete: { count: 50 },
        removeOnFail: { count: 20 }
      }
    );

    this.analysisWorker.on('completed', (job, result) => {
      logger.info({ jobId: job.id, type: job.data.type }, 'Analysis job completed');
    });

    this.analysisWorker.on('failed', (job, err) => {
      logger.error({ jobId: job?.id, error: err.message }, 'Analysis job failed');
    });
  }

  /**
   * Setup reports worker for scheduled reporting
   */
  private async setupReportsWorker(): Promise<void> {
    this.reportsWorker = new Worker(
      'reports',
      async (job) => {
        const { type, organizationId, recipientEmails, format } = job.data as ReportJobData;
        
        try {
          logger.info({ jobId: job.id, type, organizationId }, 'Processing report job');
          
          switch (type) {
            case 'executive_summary':
              return await this.generateExecutiveSummary(organizationId, recipientEmails, format);
            case 'performance_dashboard':
              return await this.generatePerformanceDashboard(organizationId, recipientEmails, format);
            case 'scenario_analysis':
              return await this.generateScenarioAnalysis(organizationId, recipientEmails, format);
            case 'competitive_intelligence':
              return await this.generateCompetitiveIntelligence(organizationId, recipientEmails, format);
            default:
              throw new Error(`Unknown report type: ${type}`);
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Unknown error';
          logger.error({ jobId: job.id, error: errorMessage }, 'Report job failed');
          throw error;
        }
      },
      {
        connection: redis,
        concurrency: 3,
        removeOnComplete: { count: 100 },
        removeOnFail: { count: 50 }
      }
    );

    this.reportsWorker.on('completed', (job, result) => {
      logger.info({ jobId: job.id, type: job.data.type }, 'Report job completed');
    });
  }

  /**
   * Setup alerts worker for real-time notifications
   */
  private async setupAlertsWorker(): Promise<void> {
    this.alertsWorker = new Worker(
      'alerts',
      async (job) => {
        const { type, organizationId, severity, message, recipients } = job.data as AlertJobData;
        
        try {
          logger.info({ jobId: job.id, type, severity, organizationId }, 'Processing alert job');
          
          // Process different alert types
          switch (type) {
            case 'risk_threshold':
              return await this.processRiskThresholdAlert(organizationId, severity, message, recipients);
            case 'performance_anomaly':
              return await this.processPerformanceAnomalyAlert(organizationId, severity, message, recipients);
            case 'opportunity_alert':
              return await this.processOpportunityAlert(organizationId, severity, message, recipients);
            case 'critical_metric':
              return await this.processCriticalMetricAlert(organizationId, severity, message, recipients);
            default:
              throw new Error(`Unknown alert type: ${type}`);
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Unknown error';
          logger.error({ jobId: job.id, error: errorMessage }, 'Alert job failed');
          throw error;
        }
      },
      {
        connection: redis,
        concurrency: 10,
        removeOnComplete: { count: 200 },
        removeOnFail: { count: 100 }
      }
    );

    this.alertsWorker.on('completed', (job, result) => {
      logger.info({ jobId: job.id, type: job.data.type }, 'Alert job completed');
    });
  }

  /**
   * Schedule recurring analysis and report jobs
   */
  private async scheduleRecurringJobs(): Promise<void> {
    // Daily pulse analysis for all organizations
    await analysisQueue.add(
      'daily_pulse_analysis',
      {
        type: 'pulse_analysis',
        organizationId: '*', // Process all organizations
        parameters: { scope: 'daily' }
      },
      {
        repeat: { pattern: '0 6 * * *' }, // 6 AM daily
        removeOnComplete: 10,
        removeOnFail: 5
      }
    );

    // Weekly risk assessment
    await analysisQueue.add(
      'weekly_risk_assessment',
      {
        type: 'risk_assessment',
        organizationId: '*',
        parameters: { scope: 'weekly' }
      },
      {
        repeat: { pattern: '0 7 * * 1' }, // 7 AM every Monday
        removeOnComplete: 10,
        removeOnFail: 5
      }
    );

    // Monthly opportunity detection
    await analysisQueue.add(
      'monthly_opportunity_detection',
      {
        type: 'opportunity_detection',
        organizationId: '*',
        parameters: { scope: 'monthly' }
      },
      {
        repeat: { pattern: '0 8 1 * *' }, // 8 AM on the 1st of each month
        removeOnComplete: 10,
        removeOnFail: 5
      }
    );

    // Weekly executive summary reports
    await reportsQueue.add(
      'weekly_executive_summary',
      {
        type: 'executive_summary',
        organizationId: '*',
        recipientEmails: ['executives@company.com'],
        format: 'pdf'
      },
      {
        repeat: { pattern: '0 9 * * 1' }, // 9 AM every Monday
        removeOnComplete: 20,
        removeOnFail: 10
      }
    );

    logger.info('Recurring jobs scheduled successfully');
  }

  /**
   * Process pulse analysis to detect organizational health trends
   */
  private async processPulseAnalysis(organizationId: string, parameters?: Record<string, any>): Promise<any> {
    // For demo purposes, use a single organization since storage methods are limited
    const organizations = organizationId === '*' ? [{ id: 'ec61b8f6-7d87-41fd-9969-cb990ed0b10b', name: 'Fortune Enterprise Corp' }] : [{ id: organizationId, name: 'Organization' }];
    const results: any[] = [];

    for (const org of organizations.filter(Boolean)) {
      try {
        // Get recent scenarios and tasks for analysis
        const scenarios = await storage.getScenariosByOrganization(org.id);
        const tasks = await storage.getTasksByScenario('demo');
        const activities = await storage.getRecentActivities('20');

        // Analyze organizational pulse using AI
        const analysisPrompt = `Analyze the organizational health for ${org.name}:
        - Active scenarios: ${scenarios.length}
        - Recent tasks: ${tasks.length}
        - Activity level: ${activities.length} recent activities
        
        Provide insights on:
        1. Organizational agility score (1-10)
        2. Key performance indicators
        3. Areas of concern or risk
        4. Recommendations for improvement
        
        Format as JSON with structured insights.`;

        const insights = await nlqService.processQuery({
          query: analysisPrompt,
          organizationId: org.id,
          userId: 'system'
        });

        // Store insights and check for alerts
        const result = {
          organizationId: org.id,
          organizationName: org.name,
          insights: insights.response,
          analysisDate: new Date(),
          metrics: {
            scenarioCount: scenarios.length,
            taskCount: tasks.length,
            activityLevel: activities.length
          }
        };

        results.push(result);

        // Check if we need to trigger alerts
        await this.checkForAlerts(org.id, result);

      } catch (error) {
        logger.error({ organizationId: org.id, error: error instanceof Error ? error.message : 'Unknown error' }, 'Error in pulse analysis');
      }
    }

    return results;
  }

  /**
   * Process risk assessment analysis
   */
  private async processRiskAssessment(organizationId: string, parameters?: Record<string, any>): Promise<any> {
    // Implementation for comprehensive risk assessment
    logger.info({ organizationId }, 'Processing risk assessment');
    
    // This would analyze various risk factors and provide comprehensive assessment
    return {
      organizationId,
      riskLevel: 'medium',
      riskFactors: ['market volatility', 'supply chain disruption'],
      mitigationStrategies: ['diversify suppliers', 'hedge currency exposure'],
      analysisDate: new Date()
    };
  }

  /**
   * Process opportunity detection analysis
   */
  private async processOpportunityDetection(organizationId: string, parameters?: Record<string, any>): Promise<any> {
    logger.info({ organizationId }, 'Processing opportunity detection');
    
    return {
      organizationId,
      opportunities: [
        { type: 'market_expansion', confidence: 0.85, description: 'Emerging market opportunity in Southeast Asia' },
        { type: 'technology_adoption', confidence: 0.72, description: 'AI automation potential in operations' }
      ],
      analysisDate: new Date()
    };
  }

  /**
   * Process performance trends analysis
   */
  private async processPerformanceTrends(organizationId: string, parameters?: Record<string, any>): Promise<any> {
    logger.info({ organizationId }, 'Processing performance trends');
    
    return {
      organizationId,
      trends: {
        agility_score: { current: 8.5, trend: 'increasing', change: 0.3 },
        scenario_completion: { current: 0.87, trend: 'stable', change: 0.02 },
        team_engagement: { current: 0.82, trend: 'increasing', change: 0.05 }
      },
      analysisDate: new Date()
    };
  }

  /**
   * Generate executive summary report
   */
  private async generateExecutiveSummary(organizationId: string, recipients: string[], format: string): Promise<any> {
    logger.info({ organizationId, format }, 'Generating executive summary');
    
    // This would generate a comprehensive executive summary
    return {
      reportId: `exec-summary-${Date.now()}`,
      organizationId,
      generatedAt: new Date(),
      format,
      sections: ['key_metrics', 'strategic_initiatives', 'risk_assessment', 'recommendations'],
      deliveryStatus: 'sent'
    };
  }

  /**
   * Generate performance dashboard report
   */
  private async generatePerformanceDashboard(organizationId: string, recipients: string[], format: string): Promise<any> {
    logger.info({ organizationId, format }, 'Generating performance dashboard');
    
    return {
      reportId: `perf-dash-${Date.now()}`,
      organizationId,
      generatedAt: new Date(),
      format,
      metrics: ['agility_score', 'scenario_completion', 'task_efficiency'],
      deliveryStatus: 'sent'
    };
  }

  /**
   * Generate scenario analysis report
   */
  private async generateScenarioAnalysis(organizationId: string, recipients: string[], format: string): Promise<any> {
    logger.info({ organizationId, format }, 'Generating scenario analysis');
    
    return {
      reportId: `scenario-analysis-${Date.now()}`,
      organizationId,
      generatedAt: new Date(),
      format,
      analysisType: 'comprehensive',
      deliveryStatus: 'sent'
    };
  }

  /**
   * Generate competitive intelligence report
   */
  private async generateCompetitiveIntelligence(organizationId: string, recipients: string[], format: string): Promise<any> {
    logger.info({ organizationId, format }, 'Generating competitive intelligence');
    
    return {
      reportId: `comp-intel-${Date.now()}`,
      organizationId,
      generatedAt: new Date(),
      format,
      competitorCount: 5,
      deliveryStatus: 'sent'
    };
  }

  /**
   * Check analysis results for alert conditions
   */
  private async checkForAlerts(organizationId: string, analysisResult: any): Promise<void> {
    // Check for conditions that require alerts
    const metrics = analysisResult.metrics;
    
    // Example alert conditions
    if (metrics.scenarioCount === 0) {
      await this.scheduleAlert({
        type: 'critical_metric',
        organizationId,
        severity: 'medium',
        message: 'No active scenarios detected. Consider creating strategic scenarios to maintain organizational agility.',
        recipients: ['strategy@company.com']
      });
    }

    if (metrics.activityLevel < 5) {
      await this.scheduleAlert({
        type: 'performance_anomaly',
        organizationId,
        severity: 'low',
        message: 'Low activity levels detected. Team engagement may need attention.',
        recipients: ['management@company.com']
      });
    }
  }

  /**
   * Process different alert types
   */
  private async processRiskThresholdAlert(organizationId: string, severity: string, message: string, recipients: string[]): Promise<any> {
    logger.warn({ organizationId, severity, message }, 'Risk threshold alert triggered');
    // Would integrate with notification system (email, Slack, etc.)
    return { sent: true, type: 'risk_threshold', recipients: recipients.length };
  }

  private async processPerformanceAnomalyAlert(organizationId: string, severity: string, message: string, recipients: string[]): Promise<any> {
    logger.info({ organizationId, severity, message }, 'Performance anomaly alert triggered');
    return { sent: true, type: 'performance_anomaly', recipients: recipients.length };
  }

  private async processOpportunityAlert(organizationId: string, severity: string, message: string, recipients: string[]): Promise<any> {
    logger.info({ organizationId, severity, message }, 'Opportunity alert triggered');
    return { sent: true, type: 'opportunity_alert', recipients: recipients.length };
  }

  private async processCriticalMetricAlert(organizationId: string, severity: string, message: string, recipients: string[]): Promise<any> {
    logger.warn({ organizationId, severity, message }, 'Critical metric alert triggered');
    return { sent: true, type: 'critical_metric', recipients: recipients.length };
  }

  /**
   * Public methods for scheduling jobs
   */
  async scheduleAnalysis(data: AnalysisJobData, options?: any): Promise<void> {
    await analysisQueue.add('analysis', data, options);
    logger.info({ type: data.type, organizationId: data.organizationId }, 'Analysis job scheduled');
  }

  async scheduleReport(data: ReportJobData, options?: any): Promise<void> {
    await reportsQueue.add('report', data, options);
    logger.info({ type: data.type, organizationId: data.organizationId }, 'Report job scheduled');
  }

  async scheduleAlert(data: AlertJobData, options?: any): Promise<void> {
    await alertsQueue.add('alert', data, { ...options, priority: data.severity === 'critical' ? 1 : 5 });
    logger.info({ type: data.type, severity: data.severity }, 'Alert job scheduled');
  }

  /**
   * Get job statistics
   */
  async getJobStatistics(): Promise<{
    analysis: { waiting: number; active: number; completed: number; failed: number };
    reports: { waiting: number; active: number; completed: number; failed: number };
    alerts: { waiting: number; active: number; completed: number; failed: number };
  }> {
    const [analysisStats, reportsStats, alertsStats] = await Promise.all([
      analysisQueue.getJobCounts(),
      reportsQueue.getJobCounts(),
      alertsQueue.getJobCounts()
    ]);

    return {
      analysis: {
        waiting: analysisStats.waiting || 0,
        active: analysisStats.active || 0,
        completed: analysisStats.completed || 0,
        failed: analysisStats.failed || 0
      },
      reports: {
        waiting: reportsStats.waiting || 0,
        active: reportsStats.active || 0,
        completed: reportsStats.completed || 0,
        failed: reportsStats.failed || 0
      },
      alerts: {
        waiting: alertsStats.waiting || 0,
        active: alertsStats.active || 0,
        completed: alertsStats.completed || 0,
        failed: alertsStats.failed || 0
      }
    };
  }

  /**
   * Cleanup and shutdown
   */
  async shutdown(): Promise<void> {
    logger.info('Shutting down background job service');
    
    await Promise.all([
      this.analysisWorker?.close(),
      this.reportsWorker?.close(),
      this.alertsWorker?.close()
    ]);

    await redis.disconnect();
    logger.info('Background job service shutdown complete');
  }
}

export const backgroundJobService = BackgroundJobService.getInstance();