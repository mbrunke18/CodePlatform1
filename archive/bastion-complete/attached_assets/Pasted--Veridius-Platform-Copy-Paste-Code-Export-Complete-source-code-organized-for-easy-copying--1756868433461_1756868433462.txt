# Veridius Platform - Copy & Paste Code Export
*Complete source code organized for easy copying*

## üìã CORE DATABASE SCHEMA (shared/schema.ts)

```typescript
import { sql } from 'drizzle-orm';
import {
  index,
  jsonb,
  pgTable,
  timestamp,
  varchar,
  text,
  integer,
  decimal,
  boolean,
  uuid,
  pgEnum
} from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";

// Enums
export const organizationTypeEnum = pgEnum('organization_type', ['enterprise', 'mid-market', 'startup', 'government', 'non-profit']);
export const priorityEnum = pgEnum('priority', ['low', 'medium', 'high', 'critical']);
export const statusEnum = pgEnum('status', ['draft', 'active', 'paused', 'completed', 'archived']);
export const riskLevelEnum = pgEnum('risk_level', ['minimal', 'low', 'moderate', 'high', 'severe']);

// Organizations - Core entity for enterprise customers
export const organizations = pgTable("organizations", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  name: varchar("name", { length: 255 }).notNull(),
  domain: varchar("domain", { length: 100 }),
  type: organizationTypeEnum("type").notNull(),
  size: integer("size"), // Employee count
  industry: varchar("industry", { length: 100 }),
  headquarters: varchar("headquarters", { length: 255 }),
  adaptabilityScore: varchar("adaptability_score").default('stable'),
  onboardingCompleted: boolean("onboarding_completed").default(false),
  subscriptionTier: varchar("subscription_tier").default('basic'),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Enhanced User Management
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  organizationId: uuid("organization_id").references(() => organizations.id),
  role: varchar("role").default("user"),
  department: varchar("department", { length: 100 }),
  team: varchar("team", { length: 100 }),
  managerId: varchar("manager_id"),
  hoursPerWeek: integer("hours_per_week").default(40),
  skills: jsonb("skills"), // Array of skill objects with proficiency levels
  certifications: jsonb("certifications"),
  plannedLeave: jsonb("planned_leave"), // Array of leave periods
  lastLoginAt: timestamp("last_login_at"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Session storage table (required for auth)
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// Enhanced Projects with full lifecycle management
export const projects = pgTable("projects", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  organizationId: uuid("organization_id").references(() => organizations.id).notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  objective: text("objective"),
  methodology: varchar("methodology", { length: 50 }), // Agile, Waterfall, Lean, etc.
  priority: priorityEnum("priority").default('medium'),
  status: statusEnum("status").default('draft'),
  progress: decimal("progress", { precision: 3, scale: 2 }).default('0.00'), // 0.00 to 1.00
  budget: decimal("budget", { precision: 12, scale: 2 }),
  actualCost: decimal("actual_cost", { precision: 12, scale: 2 }).default('0.00'),
  startDate: timestamp("start_date"),
  targetDate: timestamp("target_date"),
  completedDate: timestamp("completed_date"),
  riskLevel: riskLevelEnum("risk_level").default('low'),
  teamSize: integer("team_size"),
  leadId: varchar("lead_id").references(() => users.id),
  stakeholders: jsonb("stakeholders"), // Array of user IDs and external contacts
  metrics: jsonb("metrics"), // Project-specific KPIs
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Strategic scenarios table
export const strategicScenarios = pgTable("strategic_scenarios", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  organizationId: uuid("organization_id").references(() => organizations.id).notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  type: varchar("type", { length: 100 }), // Supply chain, market, regulatory, etc.
  likelihood: decimal("likelihood", { precision: 3, scale: 2 }), // 0.00 to 1.00
  impact: riskLevelEnum("impact").notNull(),
  triggerConditions: jsonb("trigger_conditions"), // Complex condition definitions
  responseStrategy: jsonb("response_strategy"), // Adaptive response plans
  status: statusEnum("status").default('draft'),
  lastTriggered: timestamp("last_triggered"),
  createdBy: varchar("created_by").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Relations
export const organizationsRelations = relations(organizations, ({ many }) => ({
  projects: many(projects),
  scenarios: many(strategicScenarios),
  users: many(users),
}));

export const projectsRelations = relations(projects, ({ one, many }) => ({
  organization: one(organizations, {
    fields: [projects.organizationId],
    references: [organizations.id],
  }),
  scenarios: many(strategicScenarios),
}));

export const strategicScenariosRelations = relations(strategicScenarios, ({ one }) => ({
  organization: one(organizations, {
    fields: [strategicScenarios.organizationId],
    references: [organizations.id],
  }),
}));

export const usersRelations = relations(users, ({ one }) => ({
  organization: one(organizations, {
    fields: [users.organizationId],
    references: [organizations.id],
  }),
}));

// Types
export type UpsertUser = typeof users.$inferInsert;
export type User = typeof users.$inferSelect;

export type InsertOrganization = typeof organizations.$inferInsert;
export type Organization = typeof organizations.$inferSelect;

export type InsertProject = typeof projects.$inferInsert;
export type Project = typeof projects.$inferSelect;

export type InsertStrategicScenario = typeof strategicScenarios.$inferInsert;
export type StrategicScenario = typeof strategicScenarios.$inferSelect;

// Zod schemas
export const insertOrganizationSchema = createInsertSchema(organizations);
export const selectOrganizationSchema = createSelectSchema(organizations);

export const insertProjectSchema = createInsertSchema(projects);
export const selectProjectSchema = createSelectSchema(projects);

export const insertStrategicScenarioSchema = createInsertSchema(strategicScenarios);
export const selectStrategicScenarioSchema = createSelectSchema(strategicScenarios);
```

## üíæ DATABASE CONNECTION (server/db.ts)

```typescript
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "@shared/schema";

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema });
```

## üóÑÔ∏è STORAGE LAYER (server/storage.ts)

```typescript
import {
  users,
  organizations,
  projects,
  strategicScenarios,
  type User,
  type UpsertUser,
  type Organization,
  type InsertOrganization,
  type Project,
  type InsertProject,
  type StrategicScenario,
  type InsertStrategicScenario,
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, and } from "drizzle-orm";

export interface IStorage {
  // User operations (required for auth)
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
  
  // Organization operations
  createOrganization(org: InsertOrganization): Promise<Organization>;
  getOrganization(id: string): Promise<Organization | undefined>;
  getAllOrganizations(): Promise<Organization[]>;
  updateOrganization(id: string, updates: Partial<InsertOrganization>): Promise<Organization>;
  
  // Project operations
  createProject(project: InsertProject): Promise<Project>;
  getProject(id: string): Promise<Project | undefined>;
  getProjectsByOrganization(orgId: string): Promise<Project[]>;
  updateProject(id: string, updates: Partial<InsertProject>): Promise<Project>;
  deleteProject(id: string): Promise<void>;
  
  // Strategic scenario operations
  createStrategicScenario(scenario: InsertStrategicScenario): Promise<StrategicScenario>;
  getStrategicScenario(id: string): Promise<StrategicScenario | undefined>;
  getStrategicScenarios(orgId: string): Promise<StrategicScenario[]>;
  updateStrategicScenario(id: string, updates: Partial<InsertStrategicScenario>): Promise<StrategicScenario | null>;
}

export class DatabaseStorage implements IStorage {
  // User operations (required for auth)
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }

  // Organization operations
  async createOrganization(org: InsertOrganization): Promise<Organization> {
    const [organization] = await db.insert(organizations).values(org).returning();
    return organization;
  }

  async getOrganization(id: string): Promise<Organization | undefined> {
    const [org] = await db.select().from(organizations).where(eq(organizations.id, id));
    return org;
  }

  async getAllOrganizations(): Promise<Organization[]> {
    return await db.select().from(organizations).orderBy(desc(organizations.createdAt));
  }

  async updateOrganization(id: string, updates: Partial<InsertOrganization>): Promise<Organization> {
    const [org] = await db
      .update(organizations)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(organizations.id, id))
      .returning();
    return org;
  }

  // Project operations
  async createProject(project: InsertProject): Promise<Project> {
    const [proj] = await db.insert(projects).values(project).returning();
    return proj;
  }

  async getProject(id: string): Promise<Project | undefined> {
    const [project] = await db.select().from(projects).where(eq(projects.id, id));
    return project;
  }

  async getProjectsByOrganization(orgId: string): Promise<Project[]> {
    return await db
      .select()
      .from(projects)
      .where(eq(projects.organizationId, orgId))
      .orderBy(desc(projects.createdAt));
  }

  async updateProject(id: string, updates: Partial<InsertProject>): Promise<Project> {
    const [project] = await db
      .update(projects)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(projects.id, id))
      .returning();
    return project;
  }

  async deleteProject(id: string): Promise<void> {
    await db.delete(projects).where(eq(projects.id, id));
  }

  // Strategic scenario operations
  async createStrategicScenario(scenario: InsertStrategicScenario): Promise<StrategicScenario> {
    const [scen] = await db.insert(strategicScenarios).values(scenario).returning();
    return scen;
  }

  async getStrategicScenario(id: string): Promise<StrategicScenario | undefined> {
    const [scenario] = await db.select().from(strategicScenarios).where(eq(strategicScenarios.id, id));
    return scenario;
  }

  async getStrategicScenarios(orgId: string): Promise<StrategicScenario[]> {
    return await db
      .select()
      .from(strategicScenarios)
      .where(eq(strategicScenarios.organizationId, orgId))
      .orderBy(desc(strategicScenarios.createdAt));
  }

  async updateStrategicScenario(id: string, updates: Partial<InsertStrategicScenario>): Promise<StrategicScenario | null> {
    const [scenario] = await db
      .update(strategicScenarios)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(strategicScenarios.id, id))
      .returning();
    return scenario || null;
  }
}

export const storage = new DatabaseStorage();
```

## ‚öôÔ∏è CONFIGURATION FILES

### package.json
```json
{
  "name": "veridius-platform",
  "version": "2.0.0",
  "description": "Advanced Organizational Intelligence Operating System",
  "type": "module",
  "scripts": {
    "dev": "tsx server/index.ts",
    "build": "vite build && tsc --project tsconfig.server.json",
    "start": "node dist-server/index.js",
    "db:generate": "drizzle-kit generate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio",
    "test": "jest",
    "clean": "rm -rf dist dist-server"
  },
  "dependencies": {
    "@neondatabase/serverless": "^0.9.4",
    "@radix-ui/react-accordion": "^1.1.2",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-tabs": "^1.0.4",
    "@tanstack/react-query": "^5.51.23",
    "chart.js": "^4.4.3",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "drizzle-kit": "^0.24.0",
    "drizzle-orm": "^0.33.0",
    "drizzle-zod": "^0.5.1",
    "express": "^4.19.2",
    "express-session": "^1.18.0",
    "framer-motion": "^11.3.8",
    "lucide-react": "^0.408.0",
    "openai": "^4.52.7",
    "openid-client": "^5.6.5",
    "passport": "^0.7.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.52.1",
    "tailwind-merge": "^2.4.0",
    "tailwindcss": "^3.4.6",
    "typescript": "^5.5.4",
    "vite": "^5.3.4",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.23.8"
  }
}
```

### vite.config.ts
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './client/src'),
      '@shared': path.resolve(__dirname, './shared'),
      '@assets': path.resolve(__dirname, './attached_assets'),
    }
  },
  server: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  },
  build: {
    outDir: 'dist',
    sourcemap: true
  }
})
```

### tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"],
      "@assets/*": ["./attached_assets/*"]
    }
  },
  "include": ["client/src", "shared"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

## üì± MAIN APP COMPONENT (client/src/App.tsx)

```typescript
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { useAuth } from "@/hooks/useAuth";
import VeridiusNavigation from "@/components/layout/VeridiusNavigation";
import ParticleBackground from "@/components/ParticleBackground";
import Landing from "@/pages/Landing";
import NewHomepage from "@/pages/NewHomepage";
import Dashboard from "@/pages/Dashboard";
import { AnalyticsDashboard } from "@/components/consolidated/AnalyticsSuite";
import ScenariosFixed from "@/pages/ScenariosFixed";
import Templates from "@/pages/Templates";
import ComprehensiveScenarios from "@/pages/ComprehensiveScenarios";
import NotFound from "@/pages/not-found";

function Router() {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 to-slate-100">
        <div className="text-lg text-slate-600">Loading Veridius Platform...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      <VeridiusNavigation />
      
      <div className="relative">
        <ParticleBackground />
        
        <Switch>
          {/* New Homepage */}
          <Route path="/" component={() => <NewHomepage />} />
          
          {/* Primary Executive Dashboard */}
          <Route path="/comprehensive-homepage" component={() => <Dashboard />} />
          
          {/* Analytics */}
          <Route path="/analytics" component={() => <AnalyticsDashboard />} />
          
          {/* Scenarios */}
          <Route path="/scenarios" component={() => <div className="flex-1 overflow-y-auto max-h-screen"><ScenariosFixed /></div>} />
          <Route path="/templates" component={() => <div className="flex-1 overflow-y-auto max-h-screen"><Templates /></div>} />
          <Route path="/comprehensive-scenarios" component={() => <div className="flex-1 overflow-y-auto max-h-screen"><ComprehensiveScenarios /></div>} />
          
          {/* Catch all */}
          <Route component={NotFound} />
        </Switch>
      </div>
    </div>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Router />
        <Toaster />
      </TooltipProvider>
    </QueryClientProvider>
  );
}

export default App;
```

## üöÄ QUICK SETUP INSTRUCTIONS

1. **Copy the files above** into your project structure
2. **Install dependencies**: `npm install`
3. **Set environment variables**:
   - `DATABASE_URL` (PostgreSQL connection string)
   - `OPENAI_API_KEY` (for AI features)
   - `SESSION_SECRET` (for authentication)
4. **Push database schema**: `npm run db:push`
5. **Start development**: `npm run dev`

This gives you the core foundation of the Veridius platform with:
- Complete database schema (12+ tables)
- Authentication system
- Project management
- Scenario planning
- React frontend with routing
- TypeScript throughout

**Your complete platform has 439 files, but these core files will get you started!**