Yes, you absolutely need a dedicated test database. Running tests against your development or production database is highly risky and will lead to unreliable tests.
A separate test database is essential for creating a professional and effective testing environment.
## Why a Dedicated Test Database is Crucial
 * Data Isolation üõ°Ô∏è
   This is the most important reason. Your tests will create, update, and delete data constantly. A test database ensures that this temporary test data never pollutes your real development data or, even worse, your live production data. Wiping out the users table during a test run would be catastrophic in production.
 * Consistency and Predictability  repeatable tests
   Tests must be repeatable and predictable. They should pass or fail based on your code, not on the random state of the data. A dedicated test database can be wiped clean and "seeded" with specific, known data before each test run. This guarantees that your tests always start from the exact same state, making them reliable.
 * Control and Speed ‚ö°
   You have complete control over the test database. You can drop tables, run migrations, and seed large amounts of specific data without any consequences. This process is often automated and much faster in a controlled test environment (like a Docker container running on the same machine) than against a remote production database.
## How to Implement a Test Database Strategy
The standard approach is to use environment variables to switch between database connections and use a temporary database that only exists while your tests are running.
1. Use Environment Variables
Your database connection logic should check the environment and choose the correct connection string.
In your server/db.js (or wherever you initialize Drizzle), you would have logic like this:
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from '@shared/schema';

// Determine which connection string to use
const connectionString = process.env.NODE_ENV === 'test' 
  ? process.env.TEST_DATABASE_URL 
  : process.env.DATABASE_URL;

if (!connectionString) {
  throw new Error('Database URL is not set!');
}

const client = postgres(connectionString);
export const db = drizzle(client, { schema });

Your test runner (like Vitest) will automatically set process.env.NODE_ENV to 'test'.
2. Use Docker for a Temporary Database
The easiest way to manage this is with Docker. You can spin up a PostgreSQL container specifically for your tests.
 * For Local Testing: You can use docker-compose to define a database service that you start before running npm run test.
 * For CI/CD (e.g., GitHub Actions): You can use "service containers." This automatically starts a database container alongside your test job and handles networking for you.
Here's an example snippet for a docker-compose.yml file:
version: '3.8'
services:
  test-db:
    image: postgres:15
    restart: always
    environment:
      - POSTGRES_USER=testuser
      - POSTGRES_PASSWORD=testpassword
      - POSTGRES_DB=kairosync_test
    ports:
      - '5433:5432' # Map to a different port to avoid conflict with dev DB
    volumes:
      - test-db-data:/var/lib/postgresql/data

volumes:
  test-db-data:

Your TEST_DATABASE_URL would then be: postgresql://testuser:testpassword@localhost:5433/kairosync_test.
The Typical Test Workflow
With this setup, your integration test workflow (from the previous example) would look like this:
 * Start the test database container (e.g., docker-compose up -d test-db).
 * Run the test command (npm run test).
 * The test runner sets NODE_ENV='test'.
 * Your app connects to the test database via TEST_DATABASE_URL.
 * Before each test suite, you run your Drizzle migrations to ensure the schema is up-to-date.
 * Before each test, you clear out the tables and seed only the data needed for that specific test.
 * The test runs its logic and assertions.
 * The database is left in a clean state for the next test.
