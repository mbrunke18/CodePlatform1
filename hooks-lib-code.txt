# M Platform - Hooks & Utilities Code
# Utilities, Socket.IO, queries, contexts
# Generated: Fri Jan  2 06:26:16 PM UTC 2026

========================================
FILE: client/src/hooks/useAuth.ts
========================================
import { useQuery } from '@tanstack/react-query';

export interface AuthUser {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profileImageUrl?: string;
  role?: string;
  initials: string;
}

export function useAuth() {
  const { data: user, isLoading, error } = useQuery<AuthUser>({
    queryKey: ['/api/auth/user'],
    retry: false,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  const isAuthenticated = !!user && !error;

  const login = () => {
    window.location.href = '/api/login';
  };

  const logout = () => {
    window.location.href = '/api/logout';
  };

  return {
    user: user || null,
    isLoading,
    isAuthenticated,
    login,
    logout,
  };
}


========================================
FILE: client/src/hooks/useDemoTimeline.ts
========================================
import { useState, useEffect, useCallback, useRef, useMemo } from 'react';

export interface TimelineEvent {
  time: number;
  id: string;
  callback?: () => void;
}

export interface DemoTimelineConfig {
  duration: number;
  tickInterval?: number;
  speedMultiplier?: number;
  autoStart?: boolean;
  events?: TimelineEvent[];
  onComplete?: () => void;
  onTick?: (elapsedMs: number) => void;
  onPhaseChange?: (phase: string) => void;
}

export interface DemoTimelineState {
  elapsedMs: number;
  elapsedSeconds: number;
  isRunning: boolean;
  isPaused: boolean;
  isComplete: boolean;
  progress: number;
  currentPhase: string;
  formattedTime: string;
}

export interface DemoTimelineControls {
  start: () => void;
  pause: () => void;
  resume: () => void;
  reset: () => void;
  jumpTo: (ms: number) => void;
  setPhase: (phase: string) => void;
}

export function useDemoTimeline(config: DemoTimelineConfig): [DemoTimelineState, DemoTimelineControls] {
  const {
    duration,
    tickInterval = 100,
    speedMultiplier = 1,
    autoStart = false,
    events = [],
    onComplete,
    onTick,
    onPhaseChange
  } = config;

  const [elapsedMs, setElapsedMs] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [isComplete, setIsComplete] = useState(false);
  const [currentPhase, setCurrentPhase] = useState('intro');
  
  const firedEventsRef = useRef<Set<string>>(new Set());
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const lastTickRef = useRef<number>(0);

  const clearTimer = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  const start = useCallback(() => {
    clearTimer();
    setElapsedMs(0);
    setIsRunning(true);
    setIsPaused(false);
    setIsComplete(false);
    firedEventsRef.current.clear();
    lastTickRef.current = performance.now();
    
    intervalRef.current = setInterval(() => {
      const now = performance.now();
      const delta = (now - lastTickRef.current) * speedMultiplier;
      lastTickRef.current = now;
      
      setElapsedMs(prev => {
        const newElapsed = prev + delta;
        
        if (newElapsed >= duration) {
          clearTimer();
          setIsRunning(false);
          setIsComplete(true);
          onComplete?.();
          return duration;
        }
        
        onTick?.(newElapsed);
        return newElapsed;
      });
    }, tickInterval);
  }, [duration, tickInterval, speedMultiplier, onComplete, onTick, clearTimer]);

  const pause = useCallback(() => {
    clearTimer();
    setIsPaused(true);
    setIsRunning(false);
  }, [clearTimer]);

  const resume = useCallback(() => {
    if (!isPaused || isComplete) return;
    
    setIsPaused(false);
    setIsRunning(true);
    lastTickRef.current = performance.now();
    
    intervalRef.current = setInterval(() => {
      const now = performance.now();
      const delta = (now - lastTickRef.current) * speedMultiplier;
      lastTickRef.current = now;
      
      setElapsedMs(prev => {
        const newElapsed = prev + delta;
        
        if (newElapsed >= duration) {
          clearTimer();
          setIsRunning(false);
          setIsComplete(true);
          onComplete?.();
          return duration;
        }
        
        onTick?.(newElapsed);
        return newElapsed;
      });
    }, tickInterval);
  }, [isPaused, isComplete, duration, tickInterval, speedMultiplier, onComplete, onTick, clearTimer]);

  const reset = useCallback(() => {
    clearTimer();
    setElapsedMs(0);
    setIsRunning(false);
    setIsPaused(false);
    setIsComplete(false);
    setCurrentPhase('intro');
    firedEventsRef.current.clear();
  }, [clearTimer]);

  const jumpTo = useCallback((ms: number) => {
    const clampedMs = Math.min(Math.max(0, ms), duration);
    setElapsedMs(clampedMs);
    
    events.forEach(event => {
      if (event.time <= clampedMs) {
        firedEventsRef.current.add(event.id);
      } else {
        firedEventsRef.current.delete(event.id);
      }
    });
    
    if (clampedMs >= duration) {
      setIsComplete(true);
      setIsRunning(false);
    }
  }, [duration, events]);

  const setPhase = useCallback((phase: string) => {
    setCurrentPhase(phase);
    onPhaseChange?.(phase);
  }, [onPhaseChange]);

  useEffect(() => {
    events.forEach(event => {
      if (elapsedMs >= event.time && !firedEventsRef.current.has(event.id)) {
        firedEventsRef.current.add(event.id);
        event.callback?.();
      }
    });
  }, [elapsedMs, events]);

  useEffect(() => {
    if (autoStart) {
      start();
    }
    return clearTimer;
  }, [autoStart, start, clearTimer]);

  const state: DemoTimelineState = useMemo(() => {
    const elapsedSeconds = Math.floor(elapsedMs / 1000);
    const mins = Math.floor(elapsedSeconds / 60);
    const secs = elapsedSeconds % 60;
    
    return {
      elapsedMs,
      elapsedSeconds,
      isRunning,
      isPaused,
      isComplete,
      progress: duration > 0 ? (elapsedMs / duration) * 100 : 0,
      currentPhase,
      formattedTime: `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
    };
  }, [elapsedMs, isRunning, isPaused, isComplete, duration, currentPhase]);

  const controls: DemoTimelineControls = useMemo(() => ({
    start,
    pause,
    resume,
    reset,
    jumpTo,
    setPhase
  }), [start, pause, resume, reset, jumpTo, setPhase]);

  return [state, controls];
}

export function formatDemoTime(ms: number): string {
  const totalSeconds = Math.floor(ms / 1000);
  const mins = Math.floor(totalSeconds / 60);
  const secs = totalSeconds % 60;
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

export function msToSeconds(ms: number): number {
  return Math.floor(ms / 1000);
}

export function secondsToMs(seconds: number): number {
  return seconds * 1000;
}


========================================
FILE: client/src/hooks/useDynamicStrategySimulator.ts
========================================
import { useEffect, useState } from 'react';
import { dynamicStrategySimulator } from '@/services/dynamicStrategySimulator';

export function useDynamicStrategySimulator(autoStart: boolean = false) {
  const [isRunning, setIsRunning] = useState(false);
  const [status, setStatus] = useState(dynamicStrategySimulator.getStatus());

  useEffect(() => {
    if (autoStart) {
      handleStart();
    }

    const interval = setInterval(() => {
      setStatus(dynamicStrategySimulator.getStatus());
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, [autoStart]);

  const handleStart = () => {
    dynamicStrategySimulator.start();
    setIsRunning(true);
  };

  const handleStop = () => {
    dynamicStrategySimulator.stop();
    setIsRunning(false);
  };

  const launchScenario = (scenarioId: string, scenarioName: string) => {
    dynamicStrategySimulator.launchScenario(scenarioId, scenarioName);
  };

  return {
    isRunning,
    status,
    start: handleStart,
    stop: handleStop,
    launchScenario
  };
}


========================================
FILE: client/src/hooks/useExecutionWebSocket.ts
========================================
import { useEffect, useState, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

export interface AcknowledgmentEvent {
  stakeholderId: string;
  stakeholderName: string;
  acknowledgedAt: Date;
  responseTimeMinutes: number;
  timestamp: string;
}

export interface CoordinationCompleteEvent {
  coordinationTimeMinutes: number;
  acknowledgedCount: number;
  totalStakeholders: number;
  acknowledgmentRate: number;
  timestamp: string;
  executionInstanceId: string;
}

export interface TaskUpdateEvent {
  taskId: string;
  status: string;
  completedAt?: Date;
  timestamp: string;
}

export interface NotificationSentEvent {
  id: string;
  recipientId: string;
  sentAt: Date;
  timestamp: string;
}

export interface UseExecutionWebSocketReturn {
  socket: Socket | null;
  acknowledgments: AcknowledgmentEvent[];
  isComplete: boolean;
  metrics: CoordinationCompleteEvent | null;
  taskUpdates: TaskUpdateEvent[];
  notificationsSent: NotificationSentEvent[];
  isConnected: boolean;
  error: string | null;
}

/**
 * Custom hook for real-time execution tracking via WebSocket
 * Connects to Socket.IO server and listens for execution events
 */
export function useExecutionWebSocket(
  executionInstanceId: string | undefined
): UseExecutionWebSocketReturn {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [acknowledgments, setAcknowledgments] = useState<AcknowledgmentEvent[]>([]);
  const [isComplete, setIsComplete] = useState(false);
  const [metrics, setMetrics] = useState<CoordinationCompleteEvent | null>(null);
  const [taskUpdates, setTaskUpdates] = useState<TaskUpdateEvent[]>([]);
  const [notificationsSent, setNotificationsSent] = useState<NotificationSentEvent[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!executionInstanceId) {
      return;
    }

    console.log(`ðŸ”Œ Connecting to WebSocket for execution: ${executionInstanceId}`);

    // Create Socket.IO connection
    const socketInstance = io(window.location.origin, {
      path: '/socket.io/',
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: 5,
    });

    // Connection event handlers
    socketInstance.on('connect', () => {
      console.log('âœ“ WebSocket connected:', socketInstance.id);
      setIsConnected(true);
      setError(null);

      // Join the execution room
      socketInstance.emit('join-execution', executionInstanceId);
    });

    socketInstance.on('execution-joined', (data: { executionInstanceId: string }) => {
      console.log(`âœ“ Joined execution room: ${data.executionInstanceId}`);
    });

    socketInstance.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason);
      setIsConnected(false);
    });

    socketInstance.on('connect_error', (err) => {
      console.error('WebSocket connection error:', err.message);
      setError(`Connection error: ${err.message}`);
      setIsConnected(false);
    });

    socketInstance.on('reconnect', (attemptNumber) => {
      console.log(`WebSocket reconnected after ${attemptNumber} attempts`);
      setError(null);
    });

    socketInstance.on('reconnect_failed', () => {
      console.error('WebSocket reconnection failed');
      setError('Failed to reconnect to server');
    });

    // Execution event handlers
    socketInstance.on('stakeholder-acknowledged', (data: AcknowledgmentEvent) => {
      console.log('ðŸ“¬ Stakeholder acknowledged:', data.stakeholderName);
      setAcknowledgments((prev) => [...prev, data]);
    });

    socketInstance.on('coordination-complete', (data: CoordinationCompleteEvent) => {
      console.log('ðŸŽ‰ Coordination complete:', data);
      setIsComplete(true);
      setMetrics(data);
    });

    socketInstance.on('task-updated', (data: TaskUpdateEvent) => {
      console.log('ðŸ“‹ Task updated:', data);
      setTaskUpdates((prev) => [...prev, data]);
    });

    socketInstance.on('notification-sent', (data: NotificationSentEvent) => {
      console.log('ðŸ“¤ Notification sent:', data);
      setNotificationsSent((prev) => [...prev, data]);
    });

    setSocket(socketInstance);

    // Cleanup on unmount
    return () => {
      console.log(`ðŸ”Œ Disconnecting from execution: ${executionInstanceId}`);
      socketInstance.emit('leave-execution', executionInstanceId);
      socketInstance.disconnect();
      setSocket(null);
      setIsConnected(false);
    };
  }, [executionInstanceId]);

  return {
    socket,
    acknowledgments,
    isComplete,
    metrics,
    taskUpdates,
    notificationsSent,
    isConnected,
    error,
  };
}


========================================
FILE: client/src/hooks/useSyncWebSocket.ts
========================================
import { useEffect, useState, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';
import { useToast } from '@/hooks/use-toast';

interface SyncStatusUpdate {
  syncId: string;
  platform: string;
  status: 'pending' | 'syncing' | 'synced' | 'failed';
  progress?: number;
  tasksSynced?: number;
  totalTasks?: number;
  errorMessage?: string;
  executionInstanceId: string;
  timestamp: string;
}

interface SyncComplete {
  syncId: string;
  platform: string;
  externalProjectId?: string;
  externalProjectUrl?: string;
  tasksSynced: number;
  syncDurationSeconds: number;
  executionInstanceId: string;
  timestamp: string;
}

interface SyncError {
  syncId: string;
  platform: string;
  errorMessage: string;
  errorCode?: string;
  retryable: boolean;
  executionInstanceId: string;
  timestamp: string;
}

interface DocumentGenerated {
  documentId: string;
  documentType: string;
  documentName: string;
  executionInstanceId: string;
  timestamp: string;
}

interface ResourceActivated {
  resourceId: string;
  resourceType: string;
  resourceName: string;
  allocatedAmount: number;
  organizationId: string;
  timestamp: string;
}

interface UseSyncWebSocketOptions {
  executionInstanceId?: string;
  organizationId?: string;
  userId?: string;
  showToasts?: boolean;
  onSyncStatus?: (data: SyncStatusUpdate) => void;
  onSyncComplete?: (data: SyncComplete) => void;
  onSyncError?: (data: SyncError) => void;
  onDocumentGenerated?: (data: DocumentGenerated) => void;
  onResourceActivated?: (data: ResourceActivated) => void;
}

interface SyncState {
  isConnected: boolean;
  activeSyncs: Map<string, SyncStatusUpdate>;
  recentEvents: Array<SyncStatusUpdate | SyncComplete | SyncError>;
}

export function useSyncWebSocket(options: UseSyncWebSocketOptions) {
  const { toast } = useToast();
  const [socket, setSocket] = useState<Socket | null>(null);
  const [state, setState] = useState<SyncState>({
    isConnected: false,
    activeSyncs: new Map(),
    recentEvents: [],
  });
  
  const {
    executionInstanceId,
    organizationId,
    userId,
    showToasts = true,
    onSyncStatus,
    onSyncComplete,
    onSyncError,
    onDocumentGenerated,
    onResourceActivated,
  } = options;
  
  const addEvent = useCallback((event: SyncStatusUpdate | SyncComplete | SyncError) => {
    setState((prev) => ({
      ...prev,
      recentEvents: [event, ...prev.recentEvents.slice(0, 49)],
    }));
  }, []);
  
  useEffect(() => {
    const newSocket = io(window.location.origin, {
      path: '/socket.io/',
      transports: ['websocket', 'polling'],
    });
    
    newSocket.on('connect', () => {
      console.log('Sync WebSocket connected');
      setState((prev) => ({ ...prev, isConnected: true }));
      
      if (userId) {
        newSocket.emit('identify', { userId, organizationId });
      }
      
      if (executionInstanceId) {
        newSocket.emit('join-execution', executionInstanceId);
      }
    });
    
    newSocket.on('disconnect', () => {
      console.log('Sync WebSocket disconnected');
      setState((prev) => ({ ...prev, isConnected: false }));
    });
    
    newSocket.on('sync-status-update', (data: SyncStatusUpdate) => {
      console.log('Sync status update:', data);
      
      setState((prev) => {
        const newActiveSyncs = new Map(prev.activeSyncs);
        if (data.status === 'syncing' || data.status === 'pending') {
          newActiveSyncs.set(data.syncId, data);
        } else {
          newActiveSyncs.delete(data.syncId);
        }
        return { ...prev, activeSyncs: newActiveSyncs };
      });
      
      addEvent(data);
      onSyncStatus?.(data);
      
      if (showToasts && data.status === 'syncing' && data.progress === 0) {
        toast({
          title: 'Sync Started',
          description: `Syncing to ${data.platform}...`,
        });
      }
    });
    
    newSocket.on('sync-complete', (data: SyncComplete) => {
      console.log('Sync complete:', data);
      
      setState((prev) => {
        const newActiveSyncs = new Map(prev.activeSyncs);
        newActiveSyncs.delete(data.syncId);
        return { ...prev, activeSyncs: newActiveSyncs };
      });
      
      addEvent({ ...data, status: 'synced' } as any);
      onSyncComplete?.(data);
      
      if (showToasts) {
        toast({
          title: 'Sync Complete',
          description: `Successfully synced ${data.tasksSynced} tasks to ${data.platform} in ${data.syncDurationSeconds}s`,
        });
      }
    });
    
    newSocket.on('sync-error', (data: SyncError) => {
      console.log('Sync error:', data);
      
      setState((prev) => {
        const newActiveSyncs = new Map(prev.activeSyncs);
        newActiveSyncs.delete(data.syncId);
        return { ...prev, activeSyncs: newActiveSyncs };
      });
      
      addEvent({ ...data, status: 'failed' } as any);
      onSyncError?.(data);
      
      if (showToasts) {
        toast({
          title: 'Sync Failed',
          description: data.errorMessage,
          variant: 'destructive',
        });
      }
    });
    
    newSocket.on('document-generated', (data: DocumentGenerated) => {
      console.log('Document generated:', data);
      onDocumentGenerated?.(data);
      
      if (showToasts) {
        toast({
          title: 'Document Generated',
          description: `${data.documentName} is ready`,
        });
      }
    });
    
    newSocket.on('resource-activated', (data: ResourceActivated) => {
      console.log('Resource activated:', data);
      onResourceActivated?.(data);
      
      if (showToasts) {
        toast({
          title: 'Resource Activated',
          description: `${data.resourceName} is now available`,
        });
      }
    });
    
    setSocket(newSocket);
    
    return () => {
      if (executionInstanceId) {
        newSocket.emit('leave-execution', executionInstanceId);
      }
      newSocket.disconnect();
    };
  }, [executionInstanceId, organizationId, userId]);
  
  const joinExecution = useCallback((id: string) => {
    socket?.emit('join-execution', id);
  }, [socket]);
  
  const leaveExecution = useCallback((id: string) => {
    socket?.emit('leave-execution', id);
  }, [socket]);
  
  return {
    isConnected: state.isConnected,
    activeSyncs: Array.from(state.activeSyncs.values()),
    recentEvents: state.recentEvents,
    joinExecution,
    leaveExecution,
  };
}

export function useSyncStatus(executionInstanceId?: string) {
  const [syncs, setSyncs] = useState<SyncStatusUpdate[]>([]);
  
  const { activeSyncs, recentEvents, isConnected } = useSyncWebSocket({
    executionInstanceId,
    onSyncStatus: (data) => {
      setSyncs((prev) => {
        const existing = prev.findIndex((s) => s.syncId === data.syncId);
        if (existing >= 0) {
          const updated = [...prev];
          updated[existing] = data;
          return updated;
        }
        return [...prev, data];
      });
    },
    onSyncComplete: (data) => {
      setSyncs((prev) => prev.filter((s) => s.syncId !== data.syncId));
    },
    onSyncError: (data) => {
      setSyncs((prev) => prev.filter((s) => s.syncId !== data.syncId));
    },
  });
  
  return {
    isConnected,
    activeSyncs,
    syncHistory: recentEvents,
  };
}


========================================
FILE: client/src/hooks/use-toast.ts
========================================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }


========================================
FILE: client/src/hooks/useWebSocket.ts
========================================
import { useEffect, useRef, useState, useCallback } from "react";
import { io, Socket } from "socket.io-client";

interface UseWebSocketOptions {
  userId?: string;
  organizationId?: string;
  autoConnect?: boolean;
}

interface WebSocketMessage {
  type: string;
  payload?: any;
}

export function useWebSocket(options: UseWebSocketOptions = {}) {
  const { userId, organizationId, autoConnect = true } = options;
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);
  const socketRef = useRef<Socket | null>(null);
  const handlersRef = useRef<Map<string, Set<(data: any) => void>>>(new Map());

  useEffect(() => {
    if (!autoConnect) return;

    const socket = io(window.location.origin, {
      path: '/socket.io/',
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: 10,
    });

    socket.on('connect', () => {
      console.log('âœ“ WebSocket connected:', socket.id);
      setIsConnected(true);

      if (userId) {
        socket.emit('identify', { userId, organizationId });
      }
    });

    socket.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason);
      setIsConnected(false);
    });

    socket.on('connect_error', (error) => {
      console.error('WebSocket connection error:', error.message);
      setIsConnected(false);
    });

    socket.onAny((event, data) => {
      const message = { type: event, payload: data };
      setLastMessage(message);
      
      const handlers = handlersRef.current.get(event);
      if (handlers) {
        handlers.forEach(handler => handler(data));
      }
    });

    socketRef.current = socket;

    return () => {
      socket.disconnect();
      socketRef.current = null;
      setIsConnected(false);
    };
  }, [userId, organizationId, autoConnect]);

  const sendMessage = useCallback((event: string, data?: any) => {
    if (socketRef.current?.connected) {
      socketRef.current.emit(event, data);
    } else {
      console.warn('WebSocket not connected, message not sent:', event);
    }
  }, []);

  const subscribe = useCallback((event: string, handler: (data: any) => void) => {
    if (!handlersRef.current.has(event)) {
      handlersRef.current.set(event, new Set());
    }
    handlersRef.current.get(event)!.add(handler);

    return () => {
      handlersRef.current.get(event)?.delete(handler);
    };
  }, []);

  const joinRoom = useCallback((roomId: string, user: { id: string; username: string; role?: string }) => {
    sendMessage('collab:join_room', { 
      roomId, 
      user: { 
        ...user, 
        role: user.role || 'participant',
        joinedAt: new Date()
      } 
    });
  }, [sendMessage]);

  const leaveRoom = useCallback((roomId: string, userId: string) => {
    sendMessage('collab:leave_room', { roomId, userId });
  }, [sendMessage]);

  const createDecision = useCallback((roomId: string, decision: { title: string; description?: string; options: any[]; status: string; priority: string }) => {
    sendMessage('collab:create_decision', { roomId, decision });
  }, [sendMessage]);

  const castVote = useCallback((roomId: string, decisionId: string, vote: { userId: string; optionId: string; confidence: number; comment?: string }) => {
    sendMessage('collab:cast_vote', { roomId, decisionId, vote });
  }, [sendMessage]);

  const sendChatMessage = useCallback((roomId: string, userId: string, message: string) => {
    sendMessage('collab:chat_message', { roomId, userId, message });
  }, [sendMessage]);

  const joinExecution = useCallback((executionInstanceId: string) => {
    sendMessage('join-execution', executionInstanceId);
  }, [sendMessage]);

  const leaveExecution = useCallback((executionInstanceId: string) => {
    sendMessage('leave-execution', executionInstanceId);
  }, [sendMessage]);

  return {
    isConnected,
    lastMessage,
    sendMessage,
    subscribe,
    joinRoom,
    leaveRoom,
    createDecision,
    castVote,
    sendChatMessage,
    joinExecution,
    leaveExecution,
    socket: socketRef.current,
  };
}


========================================
FILE: client/src/hooks/use-mobile.tsx
========================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


========================================
FILE: client/src/lib/api.ts
========================================
import { apiRequest } from "./queryClient";

export interface Organization {
  id: string;
  name: string;
  description?: string;
  ownerId: string;
  status: string;
  createdAt: string;
}

export interface StrategicScenario {
  id: string;
  title: string;
  description?: string;
  createdBy: string;
  organizationId: string;
  status: string;
  createdAt: string;
  creatorName?: string;
  taskCount?: number;
}

export interface Task {
  id: string;
  scenarioId: string;
  description: string;
  priority: string;
  status: string;
  completed?: string;
  dueDate?: string;
  createdAt: string;
}

export interface Activity {
  id: string;
  userId: string;
  action: string;
  entityType?: string;
  entityId?: string;
  createdAt: string;
  userName: string;
}

export interface Metrics {
  activeScenarios: number;
  pendingTasks: number;
  teamMembers: number;
  agilityScore: number;
}

export const api = {
  // Organizations
  createOrganization: async (data: { name: string; description?: string }) => {
    const response = await apiRequest("POST", "/api/organizations", data);
    return response.json();
  },

  getOrganizations: async (): Promise<Organization[]> => {
    const response = await apiRequest("GET", "/api/organizations");
    return response.json();
  },

  // Scenarios
  createScenario: async (data: { 
    title: string; 
    description?: string; 
    organizationId: string;
    actionableSteps?: { description: string; priority: string }[];
  }) => {
    const response = await apiRequest("POST", "/api/scenarios", data);
    return response.json();
  },

  getRecentScenarios: async (): Promise<StrategicScenario[]> => {
    const response = await apiRequest("GET", "/api/scenarios/recent");
    return response.json();
  },

  // Tasks
  getPriorityTasks: async (): Promise<Task[]> => {
    const response = await apiRequest("GET", "/api/tasks/priority");
    return response.json();
  },

  updateTaskStatus: async (taskId: string, completed: boolean) => {
    const response = await apiRequest("PATCH", `/api/tasks/${taskId}/status`, { completed });
    return response.json();
  },

  // Activities
  getRecentActivities: async (): Promise<Activity[]> => {
    const response = await apiRequest("GET", "/api/activities/recent");
    return response.json();
  },

  // Metrics
  getDashboardMetrics: async (): Promise<Metrics> => {
    const response = await apiRequest("GET", "/api/dashboard/metrics");
    return response.json();
  },

  // AI Co-pilot
  askAI: async (query: string) => {
    const response = await apiRequest("POST", "/api/ai/analyze", { query });
    return response.json();
  },

  // Create scenario from template
  createScenarioFromTemplate: async (templateId: string, customData: any) => {
    const response = await apiRequest("POST", "/api/scenarios/from-template", { templateId, customData });
    return response.json();
  },
};


========================================
FILE: client/src/lib/authUtils.ts
========================================
export function isUnauthorizedError(error: Error): boolean {
  return /^401: .*Unauthorized/.test(error.message);
}


========================================
FILE: client/src/lib/demo-data.ts
========================================
/**
 * Demo Data System for M Platform
 * 
 * Provides realistic sample data to populate empty states and demonstrate
 * platform capabilities across all pages. All metrics are based on actual
 * Fortune 1000 customer benchmarks.
 */

export interface DemoTrigger {
  id: string;
  name: string;
  category: 'market' | 'competitive' | 'operational' | 'regulatory' | 'crisis';
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: string;
  status: 'active' | 'monitoring' | 'resolved';
  description: string;
  aiConfidence: number;
  relatedScenario: string;
}

export interface DemoPlaybookExecution {
  id: string;
  playbookName: string;
  triggerId: string;
  startedAt: string;
  completedAt: string | null;
  elapsedMinutes: number;
  status: 'running' | 'completed' | 'paused';
  tasksCompleted: number;
  tasksTotal: number;
  stakeholdersNotified: number;
  timeSavedHours: number;
  estimatedValue: number;
}

export interface DemoDecisionOutcome {
  id: string;
  title: string;
  scenario: string;
  executedAt: string;
  decisionTime: string;
  outcomeType: 'success' | 'partial' | 'learning';
  valueCaptured: number;
  lessonsLearned: string[];
  playbookRefined: boolean;
}

export interface DemoIntegrationStatus {
  id: string;
  name: string;
  platform: string;
  status: 'connected' | 'pending' | 'error';
  lastSync: string;
  dataFlowing: boolean;
  eventsMonitored: number;
}

// Sample Triggers (AI Radar detections)
export const demoTriggers: DemoTrigger[] = [
  {
    id: 'trigger-001',
    name: 'Key Competitor Announced Strategic Partnership',
    category: 'competitive',
    severity: 'high',
    timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(), // 2 hours ago
    status: 'active',
    description: 'Primary competitor announced partnership with major cloud provider, potentially threatening our enterprise segment.',
    aiConfidence: 94,
    relatedScenario: 'competitive-response'
  },
  {
    id: 'trigger-002',
    name: 'Regulatory Compliance Deadline Approaching',
    category: 'regulatory',
    severity: 'medium',
    timestamp: new Date(Date.now() - 6 * 60 * 60 * 1000).toISOString(), // 6 hours ago
    status: 'monitoring',
    description: 'New data privacy regulations take effect in 45 days. 3 systems require compliance updates.',
    aiConfidence: 98,
    relatedScenario: 'compliance-regulatory-changes'
  },
  {
    id: 'trigger-003',
    name: 'Supply Chain Disruption - Major Port Closure',
    category: 'operational',
    severity: 'critical',
    timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString(), // 30 minutes ago
    status: 'active',
    description: 'Labor strike at primary shipping port affecting 40% of inbound materials. 2-week delay projected.',
    aiConfidence: 91,
    relatedScenario: 'supply-chain-disruption'
  },
  {
    id: 'trigger-004',
    name: 'Customer Churn Pattern Detected',
    category: 'market',
    severity: 'medium',
    timestamp: new Date(Date.now() - 12 * 60 * 60 * 1000).toISOString(), // 12 hours ago
    status: 'monitoring',
    description: 'AI detected 15% increase in enterprise customer churn signals. Correlation with competitor pricing changes.',
    aiConfidence: 87,
    relatedScenario: 'customer-retention-crisis'
  },
  {
    id: 'trigger-005',
    name: 'Positive Market Opportunity - Acquisition Target',
    category: 'market',
    severity: 'high',
    timestamp: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(), // 4 hours ago
    status: 'active',
    description: 'Strategic acquisition target showing financial distress. Valuation down 35%, window for competitive bid.',
    aiConfidence: 92,
    relatedScenario: 'ma-opportunity'
  }
];

// Sample Playbook Executions
export const demoPlaybookExecutions: DemoPlaybookExecution[] = [
  {
    id: 'exec-001',
    playbookName: 'Competitive Response - Product Launch Counter',
    triggerId: 'trigger-001',
    startedAt: new Date(Date.now() - 11 * 60 * 1000).toISOString(), // 11 minutes ago
    completedAt: null,
    elapsedMinutes: 11,
    status: 'running',
    tasksCompleted: 12,
    tasksTotal: 15,
    stakeholdersNotified: 24,
    timeSavedHours: 71.8,
    estimatedValue: 850000
  },
  {
    id: 'exec-002',
    playbookName: 'Supply Chain Disruption - Alternative Sourcing',
    triggerId: 'trigger-003',
    startedAt: new Date(Date.now() - 8 * 60 * 1000).toISOString(), // 8 minutes ago
    completedAt: null,
    elapsedMinutes: 8,
    status: 'running',
    tasksCompleted: 6,
    tasksTotal: 18,
    stakeholdersNotified: 31,
    timeSavedHours: 71.9,
    estimatedValue: 1200000
  },
  {
    id: 'exec-003',
    playbookName: 'Customer Retention - Enterprise Win-Back',
    triggerId: 'trigger-004',
    startedAt: new Date(Date.now() - 48 * 60 * 60 * 1000).toISOString(), // 2 days ago
    completedAt: new Date(Date.now() - 36 * 60 * 60 * 1000).toISOString(), // 1.5 days ago
    elapsedMinutes: 720,
    status: 'completed',
    tasksCompleted: 22,
    tasksTotal: 22,
    stakeholdersNotified: 18,
    timeSavedHours: 71.0,
    estimatedValue: 2400000
  }
];

// Sample Decision Outcomes (Institutional Memory)
export const demoDecisionOutcomes: DemoDecisionOutcome[] = [
  {
    id: 'outcome-001',
    title: 'Competitive Response to Cloud Partnership',
    scenario: 'Competitive Threat Response',
    executedAt: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString(), // 14 days ago
    decisionTime: '11 minutes',
    outcomeType: 'success',
    valueCaptured: 3200000,
    lessonsLearned: [
      'Early AI detection (18 hours before public announcement) enabled proactive positioning',
      'Pre-built playbook reduced coordination time from 3 days to 11 minutes',
      'Customer outreach within 4 hours prevented 7 enterprise defections',
      'Sales team equipped with counter-messaging same day as competitor announcement'
    ],
    playbookRefined: true
  },
  {
    id: 'outcome-002',
    title: 'Supply Chain Disruption - Hurricane Response',
    scenario: 'Supply Chain Disruption',
    executedAt: new Date(Date.now() - 45 * 24 * 60 * 60 * 1000).toISOString(), // 45 days ago
    decisionTime: '9 minutes',
    outcomeType: 'success',
    valueCaptured: 5800000,
    lessonsLearned: [
      'Alternative supplier network activated within 12 minutes of trigger detection',
      'Zero production downtime despite primary supplier 3-week closure',
      'Insurance claim filed within 24 hours (vs industry avg 2 weeks)',
      'Customer commitments maintained at 100% - no delivery delays'
    ],
    playbookRefined: true
  },
  {
    id: 'outcome-003',
    title: 'Regulatory Compliance - GDPR Update',
    scenario: 'Compliance & Regulatory Changes',
    executedAt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString(), // 90 days ago
    decisionTime: '14 minutes',
    outcomeType: 'success',
    valueCaptured: 1200000,
    lessonsLearned: [
      'AI Radar detected regulatory change 6 weeks before official notice',
      'Cross-functional task force assembled in 14 minutes',
      'Compliance achieved 3 weeks ahead of deadline',
      'Avoided potential $4.5M in fines, gained competitive advantage'
    ],
    playbookRefined: false
  },
  {
    id: 'outcome-004',
    title: 'M&A Opportunity - Strategic Acquisition',
    scenario: 'M&A Opportunity',
    executedAt: new Date(Date.now() - 120 * 24 * 60 * 60 * 1000).toISOString(), // 120 days ago
    decisionTime: '10 minutes',
    outcomeType: 'partial',
    valueCaptured: 8500000,
    lessonsLearned: [
      'AI detection identified acquisition target before investment banks',
      'Due diligence team mobilized in 10 minutes',
      'Secured exclusive negotiation window (21 days)',
      'Acquisition completed at 23% below market comp (AI valuation model)',
      'Lesson: Legal review bottleneck - need pre-vetted M&A counsel roster'
    ],
    playbookRefined: true
  }
];

// Sample Integration Status
export const demoIntegrationStatus: DemoIntegrationStatus[] = [
  {
    id: 'int-001',
    name: 'Slack',
    platform: 'Communication',
    status: 'connected',
    lastSync: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 minutes ago
    dataFlowing: true,
    eventsMonitored: 1247
  },
  {
    id: 'int-002',
    name: 'Jira',
    platform: 'Project Management',
    status: 'connected',
    lastSync: new Date(Date.now() - 2 * 60 * 1000).toISOString(), // 2 minutes ago
    dataFlowing: true,
    eventsMonitored: 892
  },
  {
    id: 'int-003',
    name: 'Salesforce',
    platform: 'CRM',
    status: 'connected',
    lastSync: new Date(Date.now() - 10 * 60 * 1000).toISOString(), // 10 minutes ago
    dataFlowing: true,
    eventsMonitored: 3456
  },
  {
    id: 'int-004',
    name: 'Microsoft Teams',
    platform: 'Communication',
    status: 'connected',
    lastSync: new Date(Date.now() - 1 * 60 * 1000).toISOString(), // 1 minute ago
    dataFlowing: true,
    eventsMonitored: 678
  },
  {
    id: 'int-005',
    name: 'Google Calendar',
    platform: 'Scheduling',
    status: 'connected',
    lastSync: new Date(Date.now() - 15 * 60 * 1000).toISOString(), // 15 minutes ago
    dataFlowing: true,
    eventsMonitored: 234
  },
  {
    id: 'int-006',
    name: 'ServiceNow',
    platform: 'IT Service Management',
    status: 'pending',
    lastSync: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(), // 24 hours ago
    dataFlowing: false,
    eventsMonitored: 0
  }
];

// AI Intelligence Insights (for AI Radar)
export const demoAIInsights = {
  marketIntelligence: [
    {
      signal: 'Competitor Price Reduction',
      confidence: 89,
      impact: 'High',
      timeDetected: '2 hours ago',
      recommendation: 'Activate price matching playbook'
    },
    {
      signal: 'Industry M&A Activity Spike',
      confidence: 94,
      impact: 'Medium',
      timeDetected: '6 hours ago',
      recommendation: 'Monitor for consolidation opportunities'
    }
  ],
  operationalSignals: [
    {
      signal: 'Customer Support Ticket Surge (+45%)',
      confidence: 97,
      impact: 'High',
      timeDetected: '1 hour ago',
      recommendation: 'Investigate product quality issue'
    },
    {
      signal: 'Supplier Lead Time Extension',
      confidence: 91,
      impact: 'Medium',
      timeDetected: '4 hours ago',
      recommendation: 'Activate alternative sourcing'
    }
  ],
  strategicOpportunities: [
    {
      signal: 'Emerging Market Demand Pattern',
      confidence: 86,
      impact: 'High',
      timeDetected: '12 hours ago',
      recommendation: 'Fast-track market entry analysis'
    },
    {
      signal: 'Partnership Opportunity with Tech Leader',
      confidence: 78,
      impact: 'High',
      timeDetected: '8 hours ago',
      recommendation: 'Schedule executive alignment meeting'
    }
  ]
};

// Preparedness Metrics
export const demoPreparednessMetrics = {
  overallScore: 87,
  byCategory: {
    offensive: 92,
    defensive: 84,
    specialTeams: 86
  },
  playbooksReady: 166,
  playbooksTotal: 166,
  drillsCompleted: 24,
  drillsScheduled: 8,
  playbooksActive: 18,
  playbooksNeedUpdate: 5,
  avgResponseTime: '11.4 minutes',
  executivesAligned: 18,
  executivesTotal: 22
};

// Decision Velocity Metrics
export const demoDecisionVelocity = {
  currentQuarter: {
    decisionsExecuted: 12,
    avgDecisionTime: 11.8, // minutes
    timeSavedTotal: 864, // hours
    valueCreated: 18600000, // $18.6M
    vs_industryStandard: {
      timeReduction: 98.4, // percentage
      velocityMultiplier: 367 // 72 hours / 11.8 minutes
    }
  },
  lastQuarter: {
    decisionsExecuted: 15,
    avgDecisionTime: 12.3,
    timeSavedTotal: 1080,
    valueCreated: 24500000
  },
  trend: 'improving'
};

// Executive Dashboard Summary
export const demoDashboardSummary = {
  activePlaybooks: 2,
  triggersDetected: 5,
  tasksInProgress: 18,
  stakeholdersEngaged: 55,
  platformROI: {
    annual: 5800000,
    multiplier: 48,
    hoursSaved: 720,
    timeCompression: '12 min vs 72 hrs'
  },
  recentActivity: [
    {
      type: 'trigger',
      title: 'Competitor partnership detected',
      time: '2 hours ago',
      severity: 'high'
    },
    {
      type: 'execution',
      title: 'Competitive response playbook activated',
      time: '11 minutes ago',
      status: 'in-progress'
    },
    {
      type: 'completion',
      title: 'Supply chain disruption resolved',
      time: '2 days ago',
      value: '$1.2M saved'
    }
  ]
};

// Helper function to check if demo mode is enabled
export function isDemoMode(): boolean {
  // Check localStorage or URL params
  const urlParams = new URLSearchParams(window.location.search);
  const demoParam = urlParams.get('demo');
  const storageDemo = localStorage.getItem('m_demo_mode');
  
  return demoParam === 'true' || storageDemo === 'true';
}

// Helper function to enable demo mode
export function enableDemoMode(): void {
  localStorage.setItem('m_demo_mode', 'true');
}

// Helper function to disable demo mode
export function disableDemoMode(): void {
  localStorage.removeItem('m_demo_mode');
}


========================================
FILE: client/src/lib/demoData.ts
========================================
// Enhanced Demo Data for WOW Factor
// Impressive but realistic Fortune 1000 metrics

export const enhancedROIMetrics = {
  totalCostSavings: 12400000, // $12.4M (increased from $4.2M)
  hoursRecovered: 342, // 342 hours (increased from 156 hours)
  averageExecutionTime: 12, // 12 minutes
  executionSpeedImprovement: 500, // 500x faster (72 hours â†’ 12 minutes)
  playbookActivations: 47, // Total activations
  successRate: 94, // 94% success rate
  stakeholdersCoordinated: 47, // Average stakeholders per activation
  taskCompletionRate: 94, // 94% tasks completed
  
  // Quarterly trend data
  quarterlyMetrics: [
    { quarter: 'Q1', savings: 1800000, hours: 62, activations: 8 },
    { quarter: 'Q2', savings: 2900000, hours: 84, activations: 12 },
    { quarter: 'Q3', savings: 3500000, hours: 96, activations: 14 },
    { quarter: 'Q4', savings: 4200000, hours: 100, activations: 13 }
  ],
  
  // Category breakdown
  categoryBreakdown: [
    { category: 'Growth Initiatives', savings: 5600000, percentage: 45 },
    { category: 'Risk Management', savings: 4300000, percentage: 35 },
    { category: 'Strategic Transformation', savings: 2500000, percentage: 20 }
  ]
};

export const enhancedPreparednessScore = {
  overall: 94, // 94/100 (increased from 87)
  drillCompletion: 87, // 87% drills completed
  templateCoverage: 92, // 92% scenarios have playbooks
  stakeholderReadiness: 96, // 96% stakeholders trained
  aiConfidence: 92, // 92% AI confidence average
  
  // Component scores
  components: [
    { name: 'AI Intelligence', score: 96, status: 'excellent' },
    { name: '24/7 Monitoring', score: 94, status: 'excellent' },
    { name: 'Strategic Preparation', score: 92, status: 'excellent' },
    { name: 'Execution Framework', score: 95, status: 'excellent' },
    { name: 'Institutional Memory', score: 89, status: 'good' },
    { name: 'Integration Hub', score: 93, status: 'excellent' },
    { name: 'Executive Intelligence', score: 94, status: 'excellent' }
  ],
  
  // Trend over time
  timeline: [
    { month: 'Jan', score: 72 },
    { month: 'Feb', score: 78 },
    { month: 'Mar', score: 82 },
    { month: 'Apr', score: 85 },
    { month: 'May', score: 89 },
    { month: 'Jun', score: 92 },
    { month: 'Jul', score: 94 }
  ]
};

export const enhancedAIMetrics = {
  modulesActive: 5, // 5 AI modules
  signalsMonitored: 12, // 12 intelligence signals
  averageConfidence: 92, // 92% confidence
  patternsDetected: 1247, // 1,247 patterns identified
  predictiveAccuracy: 89, // 89% prediction accuracy
  falsePositiveRate: 4, // <5% false positives
  earlyWarningDays: 3.2, // 3.2 days average early warning
  
  // Module performance
  modules: [
    { name: 'Pulse Intelligence', confidence: 94, alerts: 47 },
    { name: 'Flux Adaptations', confidence: 91, alerts: 38 },
    { name: 'Prism Insights', confidence: 93, alerts: 52 },
    { name: 'Echo Cultural Analytics', confidence: 88, alerts: 31 },
    { name: 'Nova Innovations', confidence: 92, alerts: 44 }
  ]
};

export const enhancedExecutionMetrics = {
  averageActivationTime: 12, // 12 minutes
  traditionalTime: 72, // 72 hours (4,320 minutes)
  speedImprovement: '500x', // 500x faster
  stakeholdersNotified: 47, // Average stakeholders per activation
  tasksDistributed: 127, // Average tasks per activation
  automaticCoordination: 94, // 94% automated coordination
  manualIntervention: 6, // Only 6% requires manual intervention
  
  // Recent activations
  recentActivations: [
    { 
      id: 1, 
      name: 'Market Expansion - APAC', 
      time: 11, 
      stakeholders: 52, 
      status: 'success',
      outcome: '$8.4M revenue captured'
    },
    { 
      id: 2, 
      name: 'Competitor Response - Product Launch', 
      time: 13, 
      stakeholders: 43, 
      status: 'success',
      outcome: '18% market share protected'
    },
    { 
      id: 3, 
      name: 'Supply Chain Disruption', 
      time: 10, 
      stakeholders: 38, 
      status: 'success',
      outcome: '$3.2M cost averted'
    },
    { 
      id: 4, 
      name: 'Regulatory Compliance Update', 
      time: 14, 
      stakeholders: 29, 
      status: 'success',
      outcome: 'Zero compliance violations'
    },
    { 
      id: 5, 
      name: 'Digital Transformation Sprint', 
      time: 12, 
      stakeholders: 67, 
      status: 'success',
      outcome: '6-month roadmap in 2 weeks'
    }
  ]
};

export const enhancedInstitutionalMemory = {
  totalDecisions: 1247, // 1,247 decisions captured
  patternsIdentified: 342, // 342 patterns recognized
  playbookRefinements: 156, // 156 playbook improvements
  learningAccuracy: 89, // 89% pattern accuracy
  knowledgeCompounding: 34, // +34% playbook effectiveness
  
  // Top learnings
  topLearnings: [
    { 
      pattern: 'Competitor launches correlate with earnings calls',
      confidence: 94,
      impact: 'Early positioning advantage'
    },
    {
      pattern: 'Supply chain issues peak in Q1/Q3',
      confidence: 91,
      impact: 'Proactive inventory optimization'
    },
    {
      pattern: 'Executive buy-in increases with ROI proof',
      confidence: 96,
      impact: 'Faster stakeholder alignment'
    }
  ]
};

export const enhancedTemplateLibrary = {
  totalTemplates: 166, // 166 playbook library across 9 domains (including AI Governance)
  growthInitiatives: 40, // Growth playbooks (market expansion, innovation)
  riskManagement: 35, // Risk playbooks (compliance, protection)
  transformation: 35, // Transformation playbooks (M&A, restructuring)
  aiGovernance: 18, // AI Governance playbooks (model safety, ethics, compliance)
  customBuilt: 38, // Custom playbooks (38 industry-specific + offensive strategic)
  
  // Most used templates
  topTemplates: [
    { name: 'New Product Launch & Market Creation', category: 'Growth Initiative', uses: 18, avgSuccess: 96 },
    { name: 'Competitive Product Launch Response', category: 'Risk Management', uses: 14, avgSuccess: 92 },
    { name: 'Supply Chain Disruption', category: 'Risk Management', uses: 12, avgSuccess: 94 },
    { name: 'Market Expansion Strategy', category: 'Growth Initiative', uses: 11, avgSuccess: 89 },
    { name: 'Digital Transformation Initiative', category: 'Strategic Transformation', uses: 9, avgSuccess: 87 }
  ]
};

export const enhancedMonitoringMetrics = {
  activeDataSources: 12, // 12 intelligence signals
  triggersMonitored: 8, // 8 active triggers
  alertsLast30Days: 34, // 34 alerts generated
  averageResponseTime: '8 minutes', // 8 min avg response
  falsePositives: 4, // 4% false positive rate
  earlyWarningAdvantage: '3.2 days', // 3.2 days early warning
  
  // Signal categories
  signalSources: [
    { category: 'Market Intelligence', count: 3, status: 'active' },
    { category: 'Competitive Analysis', count: 2, status: 'active' },
    { category: 'Regulatory Monitoring', count: 2, status: 'active' },
    { category: 'Supply Chain Tracking', count: 2, status: 'active' },
    { category: 'Financial Indicators', count: 2, status: 'active' },
    { category: 'Social Sentiment', count: 1, status: 'active' }
  ]
};

// Demo Execution Plans - 12-Minute Playbooks
export const DEMO_EXECUTION_PLANS = {
  competitive_response: {
    id: 'exec-plan-001',
    name: 'Competitive Response Playbook',
    description: 'Coordinated response to aggressive competitor pricing attack',
    targetExecutionTime: 12,
    scenario: 'Competitor launches 15% price cut + aggressive marketing campaign',
    trigger: 'IF competitor_pricing < our_pricing * 0.85 AND social_sentiment < -0.3',
    stakeholders: [
      { role: 'CFO', name: 'Michael Chen', title: 'Chief Financial Officer' },
      { role: 'Legal', name: 'Sarah Johnson', title: 'General Counsel' },
      { role: 'COO', name: 'David Martinez', title: 'Chief Operating Officer' },
      { role: 'CPO', name: 'Emily Rodriguez', title: 'Chief Product Officer' },
      { role: 'CCO', name: 'James Wilson', title: 'Chief Communications Officer' },
      { role: 'CRO', name: 'Lisa Anderson', title: 'Chief Revenue Officer' },
    ],
    phases: {
      immediate: {
        name: 'IMMEDIATE Phase',
        timeWindow: '0-2 minutes',
        startMin: 0,
        endMin: 2,
        tasks: [
          {
            sequence: 1,
            title: 'CFO validates budget impact ($2M approved?)',
            description: 'Review financial reserves, confirm discount authorization up to 15%, assess revenue impact for Q4',
            role: 'CFO',
            estimatedMinutes: 2,
            priority: 'critical',
            expectedOutcome: 'Budget approval or cap limit defined'
          },
          {
            sequence: 2,
            title: 'Legal reviews compliance (any regulatory blocks?)',
            description: 'Confirm pricing changes comply with anti-trust regulations, verify no contractual conflicts with existing customers',
            role: 'Legal',
            estimatedMinutes: 2,
            priority: 'critical',
            expectedOutcome: 'Legal clearance or restrictions identified'
          }
        ]
      },
      secondary: {
        name: 'SECONDARY Phase',
        timeWindow: '2-5 minutes',
        startMin: 2,
        endMin: 5,
        dependsOn: 'IMMEDIATE Phase completion',
        tasks: [
          {
            sequence: 3,
            title: 'Operations deploys pricing adjustment',
            description: 'IF CFO approved â†’ Update pricing system, activate promotional codes, sync with billing platform',
            role: 'COO',
            estimatedMinutes: 3,
            priority: 'high',
            dependsOn: 'Task 1 (CFO approval)',
            expectedOutcome: 'New pricing live in all channels'
          },
          {
            sequence: 4,
            title: 'Product activates retention playbook',
            description: 'IF Legal cleared â†’ Enable upgrade path, activate customer success outreach, deploy competitive feature bundle',
            role: 'CPO',
            estimatedMinutes: 3,
            priority: 'high',
            dependsOn: 'Task 2 (Legal clearance)',
            expectedOutcome: 'Retention mechanisms activated'
          }
        ]
      },
      follow_up: {
        name: 'FOLLOW-UP Phase',
        timeWindow: '5-12 minutes',
        startMin: 5,
        endMin: 12,
        dependsOn: 'SECONDARY Phase completion',
        tasks: [
          {
            sequence: 5,
            title: 'Communications notifies all stakeholders',
            description: 'AFTER Operations deployed â†’ Email customers new value proposition, update website messaging, brief executive team',
            role: 'CCO',
            estimatedMinutes: 4,
            priority: 'high',
            dependsOn: 'Task 3 (Pricing deployed)',
            expectedOutcome: 'Market-wide communication executed'
          },
          {
            sequence: 6,
            title: 'Sales updates battlecard & customer messaging',
            description: 'AFTER Product activated â†’ Equip sales team with new positioning, update CRM messaging, activate competitive win-back campaign',
            role: 'CRO',
            estimatedMinutes: 3,
            priority: 'high',
            dependsOn: 'Task 4 (Retention activated)',
            expectedOutcome: 'Sales team armed and ready'
          }
        ]
      }
    },
    historicalPerformance: {
      lastExecuted: '2024-10-15T17:12:00Z',
      actualTime: 11,
      successRate: 100,
      totalExecutions: 3,
      outcome: '$2.4M revenue protected, 18% market share maintained'
    }
  },
  
  compliance_deadline: {
    id: 'exec-plan-002',
    name: 'Compliance Remediation Playbook',
    description: 'Emergency response to regulatory compliance deadline',
    targetExecutionTime: 12,
    scenario: 'GDPR audit deadline <30 days with readiness score below 80%',
    trigger: 'IF compliance_deadline < 30_days AND readiness_score < 0.8',
    stakeholders: [
      { role: 'CTO', name: 'Alexandra Kim', title: 'Chief Technology Officer' },
      { role: 'Legal', name: 'Robert Hayes', title: 'Head of Compliance' },
      { role: 'Compliance', name: 'Jennifer Lee', title: 'VP of Compliance' },
      { role: 'Procurement', name: 'Thomas Brown', title: 'Procurement Director' },
      { role: 'Executive Comms', name: 'Rachel Green', title: 'Executive Communications' },
      { role: 'External Auditor', name: 'Ernst & Young Team', title: 'Audit Partner' },
    ],
    phases: {
      immediate: {
        name: 'IMMEDIATE Phase',
        timeWindow: '0-2 minutes',
        startMin: 0,
        endMin: 2,
        tasks: [
          {
            sequence: 1,
            title: 'CTO escalates to executive team',
            description: 'Authorize overtime budget, approve contractor engagement, prioritize compliance over feature development',
            role: 'CTO',
            estimatedMinutes: 2,
            priority: 'critical',
            expectedOutcome: 'Emergency resources authorized'
          },
          {
            sequence: 2,
            title: 'Legal quantifies penalty risk exposure',
            description: 'Calculate maximum fine exposure (4% global revenue), assess reputational damage, identify critical gaps',
            role: 'Legal',
            estimatedMinutes: 2,
            priority: 'critical',
            expectedOutcome: 'Risk assessment with dollar figures'
          }
        ]
      },
      secondary: {
        name: 'SECONDARY Phase',
        timeWindow: '2-5 minutes',
        startMin: 2,
        endMin: 5,
        dependsOn: 'IMMEDIATE Phase completion',
        tasks: [
          {
            sequence: 3,
            title: 'Compliance deploys accelerated remediation',
            description: 'IF CTO approved â†’ Activate audit prep team, fast-track documentation, schedule daily war room meetings',
            role: 'Compliance',
            estimatedMinutes: 3,
            priority: 'high',
            dependsOn: 'Task 1 (CTO authorization)',
            expectedOutcome: 'Remediation plan in motion'
          },
          {
            sequence: 4,
            title: 'Procurement requests vendor documentation',
            description: 'IF Legal identified gaps â†’ Contact all vendors for security certifications, audit reports, data processing agreements',
            role: 'Procurement',
            estimatedMinutes: 3,
            priority: 'high',
            dependsOn: 'Task 2 (Gap identification)',
            expectedOutcome: 'Vendor compliance docs requested'
          }
        ]
      },
      follow_up: {
        name: 'FOLLOW-UP Phase',
        timeWindow: '5-12 minutes',
        startMin: 5,
        endMin: 12,
        dependsOn: 'SECONDARY Phase completion',
        tasks: [
          {
            sequence: 5,
            title: 'Executive Comms briefs board on status/risk',
            description: 'AFTER Compliance mobilized â†’ Prepare board memo, schedule emergency board call if needed, draft public statement contingency',
            role: 'Executive Comms',
            estimatedMinutes: 4,
            priority: 'high',
            dependsOn: 'Task 3 (Plan activated)',
            expectedOutcome: 'Board informed and aligned'
          },
          {
            sequence: 6,
            title: 'External Auditor coordinates pre-audit review',
            description: 'AFTER Vendor docs requested â†’ Schedule pre-audit walkthrough, identify quick wins, establish remediation timeline',
            role: 'External Auditor',
            estimatedMinutes: 3,
            priority: 'medium',
            dependsOn: 'Task 4 (Documentation in progress)',
            expectedOutcome: 'Audit roadmap established'
          }
        ]
      }
    },
    historicalPerformance: {
      lastExecuted: '2024-09-22T09:45:00Z',
      actualTime: 14,
      successRate: 100,
      totalExecutions: 2,
      outcome: 'Zero compliance violations, audit passed with 96% score'
    }
  }
};

// Export all enhanced metrics
export const demoData = {
  roi: enhancedROIMetrics,
  preparedness: enhancedPreparednessScore,
  ai: enhancedAIMetrics,
  execution: enhancedExecutionMetrics,
  memory: enhancedInstitutionalMemory,
  templates: enhancedTemplateLibrary,
  monitoring: enhancedMonitoringMetrics,
  executionPlans: DEMO_EXECUTION_PLANS
};


========================================
FILE: client/src/lib/queryClient.ts
========================================
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey.join("/") as string, {
      credentials: "include",
      cache: "no-store",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    if (res.status === 304) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "returnNull" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});


========================================
FILE: client/src/lib/seo.ts
========================================
export function updatePageMetadata(options: {
  title: string;
  description: string;
  ogTitle?: string;
  ogDescription?: string;
  ogImage?: string;
}) {
  // Update page title
  document.title = options.title;

  // Update or create meta description
  let metaDescription = document.querySelector('meta[name="description"]');
  if (!metaDescription) {
    metaDescription = document.createElement('meta');
    metaDescription.setAttribute('name', 'description');
    document.head.appendChild(metaDescription);
  }
  metaDescription.setAttribute('content', options.description);

  // Update or create Open Graph title
  let ogTitle = document.querySelector('meta[property="og:title"]');
  if (!ogTitle) {
    ogTitle = document.createElement('meta');
    ogTitle.setAttribute('property', 'og:title');
    document.head.appendChild(ogTitle);
  }
  ogTitle.setAttribute('content', options.ogTitle || options.title);

  // Update or create Open Graph description
  let ogDescription = document.querySelector('meta[property="og:description"]');
  if (!ogDescription) {
    ogDescription = document.createElement('meta');
    ogDescription.setAttribute('property', 'og:description');
    document.head.appendChild(ogDescription);
  }
  ogDescription.setAttribute('content', options.ogDescription || options.description);

  // Update or create Open Graph image if provided
  if (options.ogImage) {
    let ogImage = document.querySelector('meta[property="og:image"]');
    if (!ogImage) {
      ogImage = document.createElement('meta');
      ogImage.setAttribute('property', 'og:image');
      document.head.appendChild(ogImage);
    }
    ogImage.setAttribute('content', options.ogImage);
  }

  // Update or create Open Graph type
  let ogType = document.querySelector('meta[property="og:type"]');
  if (!ogType) {
    ogType = document.createElement('meta');
    ogType.setAttribute('property', 'og:type');
    document.head.appendChild(ogType);
  }
  ogType.setAttribute('content', 'website');
}


========================================
FILE: client/src/lib/utils.ts
========================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


========================================
FILE: client/src/lib/iconRenderer.tsx
========================================
import {
  LayoutDashboard,
  Brain,
  AlertTriangle,
  Target,
  Building2,
  Settings,
  Activity,
  TrendingUp,
  Users,
  Lightbulb,
  Shield,
  Zap,
  FileText,
  BarChart3,
  MessageSquare,
  Network,
  Layers,
  Radio,
  PlayCircle,
  Presentation,
  Timer,
  Rocket
} from 'lucide-react';
import { IconName } from '../navigation/config';

// Icon mapping from name to component
const iconMap = {
  LayoutDashboard,
  Brain,
  AlertTriangle,
  Target,
  Building2,
  Settings,
  Activity,
  TrendingUp,
  Users,
  Lightbulb,
  Shield,
  Zap,
  FileText,
  BarChart3,
  MessageSquare,
  Network,
  Layers,
  Radio,
  PlayCircle,
  Presentation,
  Timer,
  Rocket
} as const;

// Icon renderer function that converts icon names to JSX components
export function renderIcon(iconName: IconName, className?: string) {
  const IconComponent = iconMap[iconName];
  if (!IconComponent) {
    console.warn(`Icon "${iconName}" not found in iconMap`);
    return null;
  }
  return <IconComponent className={className} />;
}

// Helper function with default styling for navigation icons
export function renderNavigationIcon(iconName: IconName, size: 'sm' | 'md' = 'md') {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-5 w-5'
  };
  return renderIcon(iconName, sizeClasses[size]);
}

========================================
FILE: client/src/contexts/CustomerContext.tsx
========================================
import { createContext, useContext, ReactNode } from 'react';
import { useQuery } from '@tanstack/react-query';

interface Department {
  id: string;
  name: string;
  description?: string;
  headcount?: number;
  leaderId?: string;
  leaderName?: string;
}

interface Stakeholder {
  id: string;
  name: string;
  email: string;
  role: string;
  department: string;
  approvalLimit?: number;
  canApproveActivations: boolean;
}

interface Organization {
  id: string;
  name: string;
  industry?: string;
  employeeCount?: number;
  primaryContact?: string;
  primaryEmail?: string;
}

interface CustomerMetrics {
  friTarget: number;
  friCurrent: number;
  velocityTarget: number;
  velocityCurrent: number;
  coverageTarget: number;
  coverageCurrent: number;
}

interface CustomerContextType {
  organization: Organization | null;
  departments: Department[];
  stakeholders: Stakeholder[];
  metrics: CustomerMetrics;
  isLoading: boolean;
  isConfigured: boolean;
  companyName: string;
  primaryContact: string;
  primaryEmail: string;
}

const defaultMetrics: CustomerMetrics = {
  friTarget: 84.4,
  friCurrent: 72.3,
  velocityTarget: 12,
  velocityCurrent: 18,
  coverageTarget: 95,
  coverageCurrent: 78,
};

const CustomerContext = createContext<CustomerContextType>({
  organization: null,
  departments: [],
  stakeholders: [],
  metrics: defaultMetrics,
  isLoading: true,
  isConfigured: false,
  companyName: 'Your Organization',
  primaryContact: 'Admin',
  primaryEmail: 'admin@company.com',
});

export function CustomerProvider({ children }: { children: ReactNode }) {
  const { data: rawOrganizations, isLoading: orgsLoading } = useQuery<any[]>({
    queryKey: ['/api/organizations'],
  });

  const { data: rawDepartments, isLoading: deptsLoading } = useQuery<any[]>({
    queryKey: ['/api/config/departments'],
  });

  const { data: rawMetrics, isLoading: metricsLoading } = useQuery<any[]>({
    queryKey: ['/api/config/success-metrics'],
  });

  const organizations = Array.isArray(rawOrganizations) ? rawOrganizations : [];
  const apiDepartments = Array.isArray(rawDepartments) ? rawDepartments : [];
  const apiMetrics = Array.isArray(rawMetrics) ? rawMetrics : [];

  const organization = organizations[0] || null;
  
  const departments: Department[] = apiDepartments.map((d: any) => ({
    id: d.id?.toString() || d.id,
    name: d.name,
    description: d.description,
    headcount: d.headcount,
    leaderId: d.leader_id || d.leaderId,
    leaderName: d.leader_name || d.leaderName,
  }));

  const friMetric = apiMetrics.find((m: any) => m.metric_type === 'fri' || m.metricType === 'fri');
  const velocityMetric = apiMetrics.find((m: any) => m.metric_type === 'velocity' || m.metricType === 'velocity');
  const coverageMetric = apiMetrics.find((m: any) => m.metric_type === 'coverage' || m.metricType === 'coverage');

  const metrics: CustomerMetrics = {
    friTarget: friMetric?.target_value || friMetric?.targetValue || defaultMetrics.friTarget,
    friCurrent: friMetric?.current_value || friMetric?.currentValue || defaultMetrics.friCurrent,
    velocityTarget: velocityMetric?.target_value || velocityMetric?.targetValue || defaultMetrics.velocityTarget,
    velocityCurrent: velocityMetric?.current_value || velocityMetric?.currentValue || defaultMetrics.velocityCurrent,
    coverageTarget: coverageMetric?.target_value || coverageMetric?.targetValue || defaultMetrics.coverageTarget,
    coverageCurrent: coverageMetric?.current_value || coverageMetric?.currentValue || defaultMetrics.coverageCurrent,
  };

  const isLoading = orgsLoading || deptsLoading || metricsLoading;
  const isConfigured = !!organization && departments.length > 0;

  const companyName = organization?.name || 'Your Organization';
  const primaryContact = organization?.primary_contact || organization?.primaryContact || 'Admin';
  const primaryEmail = organization?.primary_email || organization?.primaryEmail || 'admin@company.com';

  return (
    <CustomerContext.Provider
      value={{
        organization,
        departments,
        stakeholders: [],
        metrics,
        isLoading,
        isConfigured,
        companyName,
        primaryContact,
        primaryEmail,
      }}
    >
      {children}
    </CustomerContext.Provider>
  );
}

export function useCustomer() {
  const context = useContext(CustomerContext);
  if (!context) {
    throw new Error('useCustomer must be used within a CustomerProvider');
  }
  return context;
}

export function useDepartments() {
  const { departments, isLoading } = useCustomer();
  return { departments, isLoading };
}

export function useCompanyName() {
  const { companyName } = useCustomer();
  return companyName;
}

export function useCustomerMetrics() {
  const { metrics, isLoading } = useCustomer();
  return { metrics, isLoading };
}


========================================
FILE: client/src/contexts/DemoController.tsx
========================================
import { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';
import { useLocation } from 'wouter';

export interface DemoScene {
  id: string;
  title: string;
  subtitle: string;
  description: string;
  type: 'executive' | 'navigation' | 'interaction' | 'summary' | 'decision';
  phase: 'detection' | 'planning' | 'response' | 'execution' | 'measurement';
  route?: string;
  duration: number; // in milliseconds
  narration: string;
  targetElements?: string[]; // data-testid values to highlight
  persona?: 'ceo' | 'coo' | 'chro' | 'cto' | 'cio' | 'cdo' | 'ciso' | 'cfo';
  industry?: 'healthcare' | 'finance' | 'manufacturing' | 'retail' | 'general';
  isDecisionPoint?: boolean;
  decisionOptions?: Array<{
    id: string;
    label: string;
    description: string;
    nextSceneId: string;
    persona?: 'ceo' | 'coo' | 'chro' | 'cto' | 'cio' | 'cdo' | 'ciso' | 'cfo';
    focus: 'strategy' | 'operations' | 'people' | 'technology' | 'digital' | 'data' | 'security' | 'finance' | 'crisis' | 'innovation';
  }>;
  actions?: Array<{
    type: 'click' | 'hover' | 'scroll' | 'wait';
    target?: string;
    delay?: number;
  }>;
  executiveStep?: number; // For syncing with ExecutiveDemo
}

export interface DemoState {
  isActive: boolean;
  isPaused: boolean;
  currentScene: number;
  totalScenes: number;
  progress: number;
  presentationMode: boolean;
  autoAdvance: boolean;
  selectedPersona?: 'ceo' | 'coo' | 'chro' | 'cto' | 'cio' | 'cdo' | 'ciso' | 'cfo';
  selectedIndustry?: 'healthcare' | 'finance' | 'manufacturing' | 'retail' | 'general';
  decisionPath: string[];
  waitingForDecision: boolean;
  currentExecutiveStep: number;
}

interface DemoControllerContextType {
  state: DemoState;
  startDemo: () => void;
  pauseDemo: () => void;
  resumeDemo: () => void;
  stopDemo: () => void;
  nextScene: () => void;
  prevScene: () => void;
  jumpToScene: (sceneIndex: number) => void;
  togglePresentationMode: () => void;
  makeDecision: (optionId: string) => void;
  setPersona: (persona: 'ceo' | 'coo' | 'chro' | 'cto' | 'cio' | 'cdo' | 'ciso' | 'cfo') => void;
  setIndustry: (industry: 'healthcare' | 'finance' | 'manufacturing' | 'retail' | 'general') => void;
  setExecutiveStep: (step: number) => void;
  currentSceneData: DemoScene | null;
  allScenes: DemoScene[];
}

const DemoControllerContext = createContext<DemoControllerContextType | null>(null);

export const useDemoController = () => {
  const context = useContext(DemoControllerContext);
  if (!context) {
    throw new Error('useDemoController must be used within a DemoControllerProvider');
  }
  return context;
};

// Persona-specific narration configurations for adaptive demo experience
const personaNarrations = {
  ceo: {
    intro: 'Welcome to M. Let me show you how CEOs use executive triggers to detect crises days before competitors. You\'ll see a supplier disruption crisis simulation - the same scenario that traditionally takes 72 hours to coordinate. In M, it executes in 12 minutes. First, I\'ll show you the Crisis Response Center where you\'ll see an active crisis alert.',
    detection: 'Look at the red alert banner at the top - this is what appears when one of YOUR executive triggers fires. Notice the supplier name "AcmeParts" and the severity level. This trigger detected financial distress 72 hours before your competitors will hear about it through news. Click the "View Crisis Response" button to see the full crisis dashboard with all the details and recommended playbooks.',
    analysis: 'This is the Crisis Response Center. See the active crisis card showing AcmeParts? Notice the countdown timer - it tracks how quickly you respond. The traditional industry standard is 72 hours. M targets 12 minutes. Below, you see the crisis metrics: severity, affected departments, estimated impact. The recommended playbook "SCM-001" is ready to activate with one click. This is your strategic command center.',
    decision: 'Now you\'ll activate the playbook. One click sends role-specific tasks to every department simultaneously. The CFO gets financial protocols, COO gets operational steps, CHRO gets workforce communications - all coordinated through the platform. Notice the task tracker showing 12 tasks being distributed across teams. This is the power of pre-configured playbooks - no meetings needed to coordinate response.',
    activation: 'Watch the task tracker in real-time. Each department receives their specific playbook steps automatically. Procurement is finding alternative suppliers, Production is adjusting schedules, Finance is activating payment protocols, Communications is preparing customer updates. All 12 tasks are executing in parallel across 5 departments. This coordinated response is what makes the 12-minute execution possible.',
    execution: 'The countdown timer shows 9 minutes elapsed. Tasks are completing in real-time - green checkmarks show finished items. Traditional crisis response takes 72 hours because of sequential coordination delays. M eliminates those delays by giving everyone their playbook simultaneously. Notice how different departments see different tasks - that\'s role-based playbook distribution. Every stakeholder knows exactly what to do.',
    results: 'Crisis resolved in 12 minutes. The ROI Dashboard shows what this means: $12M revenue protected, 71 hours saved compared to traditional response, 5-day competitive advantage. Your Executive Preparedness Score increases because you practiced crisis response. This is how Fortune 1000 executives are transforming decision velocity - from 72 hours to 12 minutes through pre-configured playbooks and executive triggers.'
  },
  coo: {
    intro: 'Let me show you how COOs use M to maintain production continuity during supplier disruptions. You\'ll see how operational triggers detect capacity risks before they impact production. The same supplier crisis that would traditionally shut down production lines for days gets resolved in 12 minutes through coordinated playbook execution. I\'ll walk you through the Crisis Response Center.',
    detection: 'See the alert banner? Your operational trigger detected "Critical Supplier Capacity Risk" for AcmeParts - impacting 3 production facilities. Notice the metrics: 35% of manufacturing capacity at risk, 847 affected employees. Traditional operations teams discover this 48 hours after production stops. This trigger gave you 72 hours advance warning. Click to view the operational dashboard with facility-specific impact analysis.',
    analysis: 'The Crisis Response Center shows real-time production impact. Look at the affected capacity metrics, facility dependencies, and operational KPIs. The playbook "OPS-001 Production Continuity" is ready to activate. This dashboard gives you complete operational intelligence in 60 seconds - information that traditionally takes 12 hours of calls with facility managers to gather. Notice the recommended actions and success probability.',
    decision: 'Activate the Production Continuity playbook. Watch how one click distributes facility-specific tasks: Plant A gets rebalanced schedules, Plant B gets alternative material specs, Quality gets supplier protocols, Logistics gets shipping reroutes. Traditional approach requires 8 hours of conference calls coordinating 3 facilities. M distributes all facility-specific playbooks simultaneously in seconds.',
    activation: 'The task tracker shows operational coordination in action. Procurement is finding alternative suppliers with capacity data, Production is receiving revised schedules, Quality is running supplier qualification protocols, Logistics is rerouting shipments. All tasks executing in parallel across multiple facilities. This is how you maintain zero production stops during supplier disruptions.',
    execution: 'Notice the countdown timer at 9 minutes. Tasks are completing across all 3 facilities simultaneously - green checkmarks show progress. Traditional operations coordination happens sequentially through phone calls and emails, causing production delays. M gives every facility manager their specific playbook at the same time. That\'s why you can maintain 94% on-time delivery even during crises.',
    results: '12-minute operational response complete. The ROI Dashboard shows production maintained with zero unplanned downtime, $2.1M saved in rush orders and expedite fees, 94% on-time delivery preserved. Your Executive Preparedness Score increases for operational excellence. This is how modern COOs are protecting production continuity - coordinated facility response through pre-configured playbooks.'
  },
  chro: {
    intro: 'Let me show you how CHROs use M for people-first crisis management. You\'ll see how workforce triggers detect employee impact before rumors spread. The same supplier crisis that could trigger mass resignations gets handled through proactive communication in 12 minutes. Traditional HR discovers workforce impact 3-5 days after crisis starts. I\'ll show you the workforce stabilization playbook.',
    detection: 'The alert banner shows "Employee Impact Alert" for 847 affected workers. Your workforce trigger detected high facility risk, sentiment score drops, and turnover risk all firing together. Notice the people metrics: departments at risk, retention probability, sentiment trends. Traditional HR finds out about workforce impact through exit interviews days later. This trigger enables proactive protection. Click to see the workforce dashboard.',
    analysis: 'The Crisis Response Center displays complete workforce intelligence. See the 847 affected employees, retention risk analysis, and sentiment data showing a 12-point morale drop. The playbook "HR-001 Workforce Stabilization" is ready. This dashboard gives you workforce intelligence in 45 seconds that traditionally takes 5 days of meetings to gather. Notice the manager readiness assessment and retention strategies.',
    decision: 'Activate the Workforce Stabilization playbook. Watch how simultaneous communication reaches all stakeholders: 847 employees get personalized impact letters, 23 facility managers receive talking points and Q&A guides, HR team gets retention frameworks. Traditional HR takes 3 days drafting memos and scheduling meetings - during which rumors spread. M delivers transparent communication to everyone in 12 minutes.',
    activation: 'The task tracker shows people-focused coordination. Employee communication is sending personalized updates explaining job security, Manager portal is delivering briefing guides, HR is activating retention strategies, Culture team is monitoring sentiment. All workforce tasks executing simultaneously. This proactive transparency prevents the anxiety and turnover that destroys culture during crises.',
    execution: 'Countdown timer shows 9 minutes. Tasks completing across workforce management: employees informed, managers briefed and confident, sentiment being tracked in real-time. Traditional HR response causes preventable turnover through communication delays. M prevents turnover through immediate transparency. See the sentiment score recovering from proactive communication - that\'s culture preservation in action.',
    results: '12-minute workforce response complete. The ROI Dashboard shows 97% retention preserved (vs 63% industry average during crises), $890K saved in replacement costs, 23/23 managers felt prepared and supported. Your Executive Preparedness Score increases for people-first leadership. This is how modern CHROs protect talent and culture - proactive workforce communication through coordinated playbooks.'
  },
  cto: {
    intro: 'Let me show you how CTOs use M for infrastructure resilience. You\'ll see how technical triggers detect dependency risks before system failures. The same infrastructure crisis that would cause 6-hour war rooms gets resolved through automated failover in 12 minutes. Traditional CTOs discover tech problems 6-12 hours after users report issues. I\'ll walk you through infrastructure continuity.',
    detection: 'The alert banner shows "Infrastructure Dependency Risk" - your supplier disruption affected cloud services impacting ERP, PLM, and supply chain systems. Notice the technical metrics: affected systems, dependency chain, failover status. Traditional IT discovers this through user complaints hours after impact begins. This trigger gave you 72 hours advance warning before critical failure. Click to see the infrastructure dashboard.',
    analysis: 'The Crisis Response Center displays complete architecture intelligence. See the affected systems: ERP with 1,200 users, PLM with 340 engineers, supply chain platform. Dependency analysis shows 47 microservices, 23 APIs, 12 databases at risk. The playbook "TECH-001 Infrastructure Continuity" shows automated failover ready. This dashboard gives you architecture intelligence in 90 seconds vs 8-hour war room analysis. Notice the backup region status.',
    decision: 'Activate the Infrastructure Continuity playbook. Watch how automated failover executes: backup region activates, load balancers reroute traffic, API gateways update, engineering teams receive runbooks. Traditional approach requires 6-hour war rooms with architects and DevOps manually coordinating failover. M orchestrates automated failover with zero manual scripts or tribal knowledge required.',
    activation: 'The task tracker shows infrastructure orchestration. Automated failover is routing traffic across 47 microservices, database replication is confirming sync, engineering teams are receiving system-specific runbooks, SRE dashboard is showing migration progress. All technical tasks executing in parallel. This automated response is how you maintain 99.8% uptime during infrastructure crises.',
    execution: 'Countdown timer shows 9 minutes. Tasks completing across infrastructure layers: cloud failing over automatically, API traffic rerouting seamlessly, engineers monitoring dashboards, users experiencing zero service interruption. Traditional manual failover causes service degradation and downtime. M automated execution maintains seamless continuity. See the uptime metric staying at 99.8% - that\'s infrastructure resilience in action.',
    results: '12-minute infrastructure failover complete. The ROI Dashboard shows 99.8% uptime maintained (vs 94% industry average during infrastructure failures), zero user productivity loss, $1.8M saved in downtime costs, 18 engineers freed for innovation work. Your Executive Preparedness Score increases for technical excellence. This is how modern CTOs protect infrastructure - automated failover through orchestrated playbooks.'
  },
  cio: {
    intro: 'Let me show you how CIOs use M for digital operations continuity. You\'ll see how IT triggers detect system risks before help desk overload. The same ERP disruption that would generate 340 tickets per hour gets resolved through automated recovery in 12 minutes. Traditional CIOs discover issues 4-8 hours after users start complaining. I\'ll demonstrate digital operations recovery.',
    detection: 'The alert banner shows "Business Critical System Risk" - supplier disruption affected ERP connectivity for 1,200 users across finance, operations, and HR. Notice the IT metrics: affected users, system criticality, compliance status. Traditional IT learns about this through help desk ticket queues hours after frustration peaks. This trigger enables proactive recovery before ticket avalanche. Click to see the IT operations dashboard.',
    analysis: 'The Crisis Response Center displays complete digital service intelligence. See the 1,200 affected users across 8 departments, ERP criticality for payroll and procurement, SOX compliance risk, projected 340 tickets/hour without response. The playbook "IT-001 Digital Operations Recovery" shows backup systems ready. This dashboard gives you IT intelligence in 60 seconds vs 6-hour incident coordination. Notice the compliance audit trail protection.',
    decision: 'Activate the Digital Operations Recovery playbook. Watch how automated recovery executes: backup ERP activates from hot standby, user communication triggers, service desk receives handling scripts, vendor SLA enforcement begins, compliance documentation auto-generates. Traditional IT requires 8-hour incident commander calls and team huddles. M coordinates recovery with zero phone tag.',
    activation: 'The task tracker shows IT orchestration. Backup systems are activating automatically, user portal is displaying service status, service desk is receiving call scripts and workarounds, vendor management is sending SLA notifications, compliance is getting audit documentation. All IT tasks executing in parallel. This coordinated response prevents help desk chaos and compliance violations.',
    execution: 'Countdown timer shows 9 minutes. Tasks completing across IT operations: systems failing over to backup, users receiving proactive updates, service desk handling calls confidently, compliance automatically documented. Traditional IT response causes user frustration and ticket avalanches. M maintains productivity through seamless failover. See the 99.5% SLA maintained and zero compliance violations - that\'s IT excellence.',
    results: '12-minute digital operations recovery complete. The ROI Dashboard shows 99.6% service availability maintained (vs 92% industry average), 87% user satisfaction from proactive communication, 68% ticket reduction, $760K saved in productivity losses, zero compliance violations. Your Executive Preparedness Score increases for IT leadership. This is how modern CIOs protect digital operations - automated recovery through coordinated playbooks.'
  },
  cdo: {
    intro: 'Let me show you how CDOs use M for data continuity and governance. You\'ll see how data triggers detect pipeline risks before executives notice stale dashboards. The same data disruption that would cause 24-hour analysis gaps gets resolved through automated failover in 12 minutes. Traditional CDOs discover data issues 18 hours after metrics stop updating. I\'ll demonstrate data operations recovery.',
    detection: 'The alert banner shows "Critical Data Pipeline Risk" - supplier disruption affected your data integration platform impacting supply chain analytics, financial reporting, and operational dashboards. Notice the data metrics: affected pipelines, downstream impact, quality degradation. Traditional data teams discover this when executives complain about stale dashboards. This trigger enables proactive data continuity before quality suffers. Click to see the data operations dashboard.',
    analysis: 'The Crisis Response Center displays complete data ecosystem intelligence. See the affected pipelines: 34 supply chain sources, 12 financial sources, 28 operational KPIs. Downstream impact shows 127 dashboards, 43 reports, 18 ML models at risk. The playbook "DATA-001 Data Continuity & Governance" shows alternative sources ready. This dashboard gives you data intelligence in 75 seconds vs 16-hour dependency analysis. Notice the governance certification protection.',
    decision: 'Activate the Data Continuity & Governance playbook. Watch how automated data failover executes: alternative sources activate, quality validation runs, pipeline orchestration reroutes 74 data flows, governance system documents lineage, ML models retrain. Traditional data response requires 12-hour emergency meetings coordinating manual workarounds. M maintains data quality through automated orchestration.',
    activation: 'The task tracker shows data operations orchestration. Alternative data sources are connecting from backup providers, quality validation is running automated checks, pipeline orchestration is rerouting flows, downstream analytics are receiving freshness notifications, governance is documenting certifications. All data tasks executing in parallel. This automated response maintains executive decision-making capability.',
    execution: 'Countdown timer shows 9 minutes. Tasks completing across data operations: alternative sources flowing data, quality scores validating at 98.7%, dashboards updating normally, executives seeing fresh insights, governance maintaining certification. Traditional data response causes executive blind spots and compliance risks. M maintains continuous data flow. See the 98.7% quality maintained and zero governance violations - that\'s data excellence.',
    results: '12-minute data continuity complete. The ROI Dashboard shows 98.7% quality maintained (vs 79% industry average during disruptions), zero executive decision-making delays, $1.2M in preserved analytics value, $640K saved in manual workaround efforts, complete governance audit trail. Your Executive Preparedness Score increases for data leadership. This is how modern CDOs protect data operations - automated failover maintaining certified quality through coordinated playbooks.'
  },
  ciso: {
    intro: 'Let me show you how CISOs use M for security incident response. You\'ll see how threat triggers detect vendor security risks before breach escalation. The same security incident that would take 16 hours to contain gets isolated through zero-trust protocols in 12 minutes. Traditional CISOs discover vendor breaches 12 hours after notification. I\'ll demonstrate vendor security incident response.',
    detection: 'The alert banner shows "Vendor Security Incident Risk" - supplier faced a security incident with 3 admin accounts, 12 API integrations, and access to manufacturing data potentially compromised. Notice the security metrics: affected assets, attack surface, regulatory risk. Traditional security learns about vendor breaches hours after initial compromise. This trigger enables immediate containment before lateral movement. Click to see the security operations dashboard.',
    analysis: 'The Crisis Response Center displays complete threat intelligence. See the affected assets: 12 API integrations, 3 vendor admin accounts with elevated privileges, VPN access to production network. Attack surface shows read access to inventory systems and API keys to supply chain platform. The playbook "SEC-001 Vendor Security Incident" shows zero-trust protocols ready. This dashboard gives you security intelligence in 90 seconds vs 10-hour threat analysis. Notice the 72-hour breach notification countdown.',
    decision: 'Activate the Vendor Security Incident playbook. Watch how zero-trust containment executes: vendor access revoked immediately, systems isolated through network microsegments, security posture assessed, incident response activated, forensics preserved, stakeholder communication triggered. Traditional security requires 8-hour SOC war rooms before containment begins. M isolates threats in 12 minutes preventing lateral movement.',
    activation: 'The task tracker shows security orchestration. Vendor access review is running automated privilege audit, access revocation is executing zero-trust protocols disabling 12 API keys and VPN, security posture assessment is scanning for IoCs, system isolation is creating microsegments, incident response team is receiving runbooks, forensics is preserving evidence. All security tasks executing in parallel. This coordinated response prevents breach escalation.',
    execution: 'Countdown timer shows 9 minutes. Tasks completing across security operations: 100% vendor access revoked, affected systems isolated, forensics collecting evidence, incident response coordinating teams, legal preparing disclosure. Traditional security response allows containment delays and expanded exposure. M achieves immediate isolation and evidence preservation. See 100% access revoked and zero lateral movement - that\'s threat containment.',
    results: '12-minute incident containment complete. The ROI Dashboard shows 100% vendor access revoked in 12 minutes (vs 18-hour industry average), zero lateral movement, no data exfiltration, breach notification requirements met with 71 hours to spare, $4.2M saved in breach remediation costs. Your Executive Preparedness Score increases for security excellence. This is how modern CISOs protect enterprise assets - immediate zero-trust isolation through coordinated incident response playbooks.'
  },
  cfo: {
    intro: 'Let me show you how CFOs use M for financial risk mitigation. You\'ll see how financial triggers detect exposure before quarterly reviews. The same supplier disruption that would cause weeks of impact analysis gets mitigated through coordinated financial response in 12 minutes. Traditional CFOs discover exposure through auditor findings weeks after it begins. I\'ll demonstrate supplier financial risk management.',
    detection: 'The alert banner shows "Supplier Financial Exposure Alert" - supplier disruption created $12M quarterly revenue risk with $7.2M committed orders and $4.8M production capacity exposure. Notice the financial metrics: revenue at risk, cash flow impact, balance sheet exposure. Traditional finance discovers this weeks later during quarterly reviews. This trigger enables immediate mitigation before shareholder value erodes. Click to see the financial dashboard.',
    analysis: 'The Crisis Response Center displays complete financial impact intelligence. See the revenue exposure: $12M quarterly revenue at risk, $7.2M committed purchase orders, $4.8M production capacity risk. Balance sheet shows $5.3M accounts payable to failing supplier. The playbook "FIN-001 Supplier Financial Risk" shows mitigation strategies ready. This dashboard gives you financial intelligence in 60 seconds vs 48-hour scenario modeling. Notice the EPS impact projection and credit facility utilization.',
    decision: 'Financial strategy decision: Execute Supplier Financial Risk Playbook FIN-001. Traditional CFO response: Schedule treasury meetings, brief audit committee, coordinate with operations - 2-3 days before mitigation actions begin. M execution: One-click financial coordination. Alternative payment arrangements activate, cash flow models update, investor communication prepares, hedging strategies trigger, board notifications send. Financial mitigation in 12 minutes vs 72-hour traditional coordination.',
    activation: 'Playbook executing 8:03 AM: Alternative payment arrangement protocols contacting 8 backup suppliers with pricing and terms. Cash flow impact modeling running scenarios across best/expected/worst cases. Investor communication protocols preparing earnings call talking points and analyst FAQ. Hedging strategy activation reviewing commodity price protections and currency exposures. Board notification package generating financial impact summary with mitigation actions. Treasury coordinating with banking partners on credit facility optimization. Financial orchestration - no manual spreadsheets, no coordination delays.',
    execution: 'Financial orchestration: 22 financial tasks across treasury, FP&A, investor relations, audit. Alternative suppliers negotiating payment terms ($7.2M order protection), cash flow models updated (liquidity maintained at 2.8x), investor messaging prepared (proactive transparency), board briefed (full confidence in mitigation), hedging activated (commodity exposure covered). Traditional approach: Scattered analysis, delayed action, market uncertainty. M approach: Coordinated mitigation, maintained confidence, protected value. Status: $12M revenue protected, liquidity secure, shareholder communication ready.',
    results: 'Financial excellence delivered: 12-minute exposure mitigation vs 72-hour traditional financial coordination. Revenue protection: $12M quarterly revenue secured through alternative supplier arrangements. Cash flow: Liquidity maintained at 2.8x (credit facility utilization stable at 73%). Shareholder value: EPS impact limited to $0.02 vs $0.15 unmanaged scenario - $195M market cap protection. Board confidence: Proactive mitigation prevented emergency sessions. Cost avoidance: $2.7M in rush costs and penalty fees. Your Executive Preparedness Scoreâ„¢ +8 points. Top 2% of CFOs for financial risk management. Quarterly value: $7.9M in protected financial performance.'
  }
};

// Stream lined hybrid demo - Single cohesive adaptive narrative
// ALL 8 personas (CEO, COO, CHRO, CTO, CIO, CDO, CISO, CFO) experience the same 7-phase journey
// Narration dynamically injected based on selected persona for personalized experience

export const hybridDemoScenarios: DemoScene[] = [
  // Phase 1: Executive Context & Platform Introduction (ADAPTIVE BY PERSONA)
  {
    id: 'executive-intro',
    title: 'M: Your Strategic Command Center',
    subtitle: '12 Minutes vs 72 Hours - Executive Decision Velocity',
    description: 'Introduction to Strategic Execution Operating System',
    type: 'executive',
    phase: 'detection',
    route: '/hybrid-demo',
    duration: 14000,
    narration: '', // Dynamically filled from personaNarrations[persona].intro
    targetElements: ['preparedness-score-widget', 'nav-item-dashboard']
  },

  // Phase 2: Trigger Detection & Alert (ADAPTIVE BY PERSONA)
  {
    id: 'trigger-alert',
    title: 'Executive Trigger Activated',
    subtitle: 'AI-powered early warning system in action',
    description: 'Real-time trigger detection shows 5-day head start over competitors',
    type: 'navigation',
    phase: 'detection',
    route: '/hybrid-demo',
    duration: 18000,
    narration: '', // Dynamically filled from personaNarrations[persona].detection
    targetElements: ['crisis-response-center', 'crisis-active-counter', 'crisis-card-supply-chain'],
    actions: [
      { type: 'wait', delay: 3000 },
      { type: 'hover', target: 'crisis-card-supply-chain', delay: 6000 }
    ]
  },

  // Phase 3: Situation Analysis & Intelligence (ADAPTIVE BY PERSONA)
  {
    id: 'situation-analysis',
    title: 'Comprehensive Impact Analysis',
    subtitle: 'Real-time intelligence dashboard',
    description: 'Complete situational awareness across all impacted areas',
    type: 'interaction',
    phase: 'planning',
    route: '/hybrid-demo',
    duration: 16000,
    narration: '', // Dynamically filled from personaNarrations[persona].analysis
    targetElements: ['crisis-response-center', 'crisis-active-counter', 'crisis-card-supply-chain'],
    actions: [
      { type: 'wait', delay: 4000 },
      { type: 'hover', target: 'crisis-card-supply-chain', delay: 5000 }
    ]
  },

  // Phase 4: Decision Point - Playbook Activation (ADAPTIVE BY PERSONA)
  {
    id: 'decision-activation',
    title: 'Playbook Activation Decision',
    subtitle: 'One-click coordinated response',
    description: 'Traditional 18-hour coordination compressed to 12 minutes',
    type: 'interaction',
    phase: 'planning',
    route: '/hybrid-demo',
    duration: 16000,
    narration: '', // Dynamically filled from personaNarrations[persona].decision
    targetElements: ['crisis-response-center', 'button-activate-crisis', 'crisis-card-supply-chain'],
    actions: [
      { type: 'wait', delay: 3000 },
      { type: 'hover', target: 'button-activate-crisis', delay: 5000 }
    ]
  },

  // Phase 5: Playbook Execution Launch (ADAPTIVE BY PERSONA)
  {
    id: 'playbook-activation',
    title: 'Coordinated Response Execution',
    subtitle: 'Real-time stakeholder mobilization',
    description: 'Watch NFL-style playbook execution across all departments',
    type: 'interaction',
    phase: 'response',
    route: '/hybrid-demo',
    duration: 18000,
    narration: '', // Dynamically filled from personaNarrations[persona].activation
    targetElements: ['crisis-response-center', 'crisis-active-counter', 'crisis-templates-section'],
    actions: [
      { type: 'wait', delay: 4000 },
      { type: 'scroll', target: 'crisis-templates-section', delay: 6000 }
    ]
  },

  // Phase 6: Real-Time Orchestration (ADAPTIVE BY PERSONA)
  {
    id: 'execution-tracking',
    title: 'Live Execution Monitoring',
    subtitle: 'Real-time task completion and coordination',
    description: 'Complete visibility into parallel execution across organization',
    type: 'interaction',
    phase: 'execution',
    route: '/hybrid-demo',
    duration: 18000,
    narration: '', // Dynamically filled from personaNarrations[persona].execution
    targetElements: ['crisis-response-center', 'crisis-active-counter', 'crisis-card-supply-chain'],
    actions: [
      { type: 'wait', delay: 5000 },
      { type: 'hover', target: 'crisis-card-supply-chain', delay: 6000 }
    ]
  },

  // Phase 7: Results & ROI Measurement (ADAPTIVE BY PERSONA)
  {
    id: 'results-roi',
    title: 'Crisis Resolution & Impact Measurement',
    subtitle: '12 minutes vs 72 hours - Quantified value delivery',
    description: 'Complete ROI analysis and competitive benchmarking',
    type: 'executive',
    phase: 'measurement',
    route: '/hybrid-demo',
    duration: 20000,
    narration: '', // Dynamically filled from personaNarrations[persona].results
    targetElements: ['preparedness-score-widget', 'nav-item-dashboard'],
    actions: [
      { type: 'wait', delay: 5000 },
      { type: 'hover', target: 'preparedness-score-widget', delay: 7000 }
    ]
  }
];

interface DemoControllerProviderProps {
  children: React.ReactNode;
}

// Helper function to inject persona-specific narration into scenes
function getSceneWithPersonaNarration(scene: DemoScene, persona: string): DemoScene {
  const personaKey = persona as keyof typeof personaNarrations;
  
  // If persona doesn't exist in our narrations, default to 'ceo'
  const narrationsForPersona = personaNarrations[personaKey] || personaNarrations.ceo;
  
  // Map scene IDs to narration keys
  const narrationMap: Record<string, keyof typeof narrationsForPersona> = {
    'executive-intro': 'intro',
    'trigger-alert': 'detection',
    'situation-analysis': 'analysis',
    'decision-activation': 'decision',
    'playbook-activation': 'activation',
    'execution-tracking': 'execution',
    'results-roi': 'results'
  };
  
  // Get the appropriate narration key for this scene
  const narrationKey = narrationMap[scene.id];
  
  // If this scene has persona-adaptive narration, inject it
  if (narrationKey && scene.narration === '') {
    return {
      ...scene,
      narration: narrationsForPersona[narrationKey],
      persona: personaKey
    };
  }
  
  return scene;
}

export function DemoControllerProvider({ children }: DemoControllerProviderProps) {
  const [location, setLocation] = useLocation();
  const [state, setState] = useState<DemoState>({
    isActive: false,
    isPaused: false,
    currentScene: 0,
    totalScenes: hybridDemoScenarios.length,
    progress: 0,
    presentationMode: false,
    autoAdvance: true,
    selectedPersona: 'ceo', // Default to CEO
    selectedIndustry: 'manufacturing',
    decisionPath: [],
    waitingForDecision: false,
    currentExecutiveStep: 0
  });

  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // Get current scene data with dynamically injected persona narration
  const currentSceneData = state.isActive && hybridDemoScenarios[state.currentScene]
    ? getSceneWithPersonaNarration(hybridDemoScenarios[state.currentScene], state.selectedPersona || 'ceo')
    : null;
  
  // Get all scenes with persona narration injected
  const allScenes = hybridDemoScenarios.map(scene => 
    getSceneWithPersonaNarration(scene, state.selectedPersona || 'ceo')
  );

  // Navigation automation
  const navigateToScene = useCallback((scene: DemoScene) => {
    if (scene.route && scene.route !== location) {
      setLocation(scene.route);
    }
  }, [location, setLocation]);

  // Auto-advance to next scene
  const autoAdvanceScene = useCallback(() => {
    if (!state.autoAdvance || state.isPaused || !state.isActive) return;
    
    const currentScene = hybridDemoScenarios[state.currentScene];
    if (!currentScene) return;

    // Don't auto-advance if this is a decision point - wait for user interaction
    if (currentScene.isDecisionPoint) {
      setState(prev => ({ ...prev, waitingForDecision: true }));
      return;
    }

    timeoutRef.current = setTimeout(() => {
      setState(prev => {
        if (prev.currentScene >= prev.totalScenes - 1) {
          // Demo completed
          return {
            ...prev,
            isActive: false,
            currentScene: 0,
            progress: 100
          };
        }
        
        const nextSceneIndex = prev.currentScene + 1;
        const nextScene = hybridDemoScenarios[nextSceneIndex];
        
        // Navigate to next scene route
        if (nextScene.route) {
          setLocation(nextScene.route);
        }
        
        return {
          ...prev,
          currentScene: nextSceneIndex,
          progress: ((nextSceneIndex + 1) / prev.totalScenes) * 100
        };
      });
    }, currentScene.duration);
  }, [state.autoAdvance, state.isPaused, state.isActive, state.currentScene, setLocation]);

  // Clear timeout on scene changes
  const clearAdvanceTimeout = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  }, []);

  // Demo control functions
  const startDemo = useCallback(() => {
    setState(prev => ({
      ...prev,
      isActive: true,
      isPaused: false,
      currentScene: 0,
      totalScenes: hybridDemoScenarios.length,
      progress: 0,
      autoAdvance: true,
      waitingForDecision: false
      // Keep selectedPersona and selectedIndustry from previous state
    }));
    
    // Navigate to first scene
    const firstScene = hybridDemoScenarios[0];
    if (firstScene.route) {
      setLocation(firstScene.route);
    }
  }, [setLocation]);

  const pauseDemo = useCallback(() => {
    setState(prev => ({ ...prev, isPaused: true }));
    clearAdvanceTimeout();
  }, [clearAdvanceTimeout]);

  const resumeDemo = useCallback(() => {
    setState(prev => ({ ...prev, isPaused: false }));
  }, []);

  const stopDemo = useCallback(() => {
    setState(prev => ({ 
      ...prev, 
      isActive: false, 
      isPaused: false, 
      currentScene: 0, 
      progress: 0 
    }));
    clearAdvanceTimeout();
  }, [clearAdvanceTimeout]);

  const nextScene = useCallback(() => {
    setState(prev => {
      if (prev.currentScene >= prev.totalScenes - 1) {
        return { ...prev, isActive: false, progress: 100 };
      }
      
      clearAdvanceTimeout();
      const nextSceneIndex = prev.currentScene + 1;
      const nextScene = hybridDemoScenarios[nextSceneIndex];
      
      if (nextScene.route) {
        setLocation(nextScene.route);
      }
      
      return {
        ...prev,
        currentScene: nextSceneIndex,
        progress: ((nextSceneIndex + 1) / prev.totalScenes) * 100,
        isPaused: false
      };
    });
  }, [setLocation, clearAdvanceTimeout]);

  const prevScene = useCallback(() => {
    setState(prev => {
      if (prev.currentScene <= 0) return prev;
      
      clearAdvanceTimeout();
      const prevSceneIndex = prev.currentScene - 1;
      const prevScene = hybridDemoScenarios[prevSceneIndex];
      
      if (prevScene.route) {
        setLocation(prevScene.route);
      }
      
      return {
        ...prev,
        currentScene: prevSceneIndex,
        progress: ((prevSceneIndex + 1) / prev.totalScenes) * 100,
        isPaused: false
      };
    });
  }, [setLocation, clearAdvanceTimeout]);

  const jumpToScene = useCallback((sceneIndex: number) => {
    if (sceneIndex < 0 || sceneIndex >= hybridDemoScenarios.length) return;
    
    clearAdvanceTimeout();
    const targetScene = hybridDemoScenarios[sceneIndex];
    
    if (targetScene.route) {
      setLocation(targetScene.route);
    }
    
    setState(prev => ({
      ...prev,
      currentScene: sceneIndex,
      progress: ((sceneIndex + 1) / prev.totalScenes) * 100,
      isPaused: false
    }));
  }, [setLocation, clearAdvanceTimeout]);

  const togglePresentationMode = useCallback(() => {
    setState(prev => ({
      ...prev,
      presentationMode: !prev.presentationMode
    }));
  }, []);

  const setPersona = useCallback((persona: DemoState['selectedPersona']) => {
    setState(prev => ({ ...prev, selectedPersona: persona }));
  }, []);

  const setIndustry = useCallback((industry: DemoState['selectedIndustry']) => {
    setState(prev => ({ ...prev, selectedIndustry: industry }));
  }, []);

  const setExecutiveStep = useCallback((step: number) => {
    setState(prev => ({ ...prev, currentExecutiveStep: step }));
  }, []);

  const makeDecision = useCallback((optionId: string) => {
    const currentScene = hybridDemoScenarios[state.currentScene];
    if (!currentScene?.isDecisionPoint || !currentScene.decisionOptions) return;

    const selectedOption = currentScene.decisionOptions.find(opt => opt.id === optionId);
    if (!selectedOption) return;

    // If the decision sets a persona, update it
    if (selectedOption.persona) {
      setPersona(selectedOption.persona);
    }

    // Find the next scene by ID
    const nextSceneIndex = hybridDemoScenarios.findIndex(scene => scene.id === selectedOption.nextSceneId);
    
    if (nextSceneIndex !== -1) {
      const nextScene = hybridDemoScenarios[nextSceneIndex];
      if (nextScene.route) {
        setLocation(nextScene.route);
      }
      
      setState(prev => ({
        ...prev,
        currentScene: nextSceneIndex,
        progress: ((nextSceneIndex + 1) / prev.totalScenes) * 100,
        decisionPath: [...prev.decisionPath, optionId],
        waitingForDecision: false
      }));
    }
  }, [state.currentScene, setLocation, setPersona]);

  // Auto-advance effect
  useEffect(() => {
    if (state.isActive && !state.isPaused && !state.waitingForDecision) {
      autoAdvanceScene();
    }
    
    return () => clearAdvanceTimeout();
  }, [state.isActive, state.isPaused, state.currentScene, state.waitingForDecision, autoAdvanceScene, clearAdvanceTimeout]);

  // Navigate to scene route on scene change
  useEffect(() => {
    if (state.isActive && currentSceneData) {
      navigateToScene(currentSceneData);
    }
  }, [state.currentScene, state.isActive, currentSceneData, navigateToScene]);

  // AUTO-CLEANUP: Stop demo when navigating away from demo pages
  useEffect(() => {
    const isDemoRoute = location === '/executive-demo' || location === '/hybrid-demo';
    
    // If we're on a non-demo page and the demo is active, stop it
    if (!isDemoRoute && state.isActive) {
      stopDemo();
    }
  }, [location, state.isActive, stopDemo]);

  const value: DemoControllerContextType = {
    state,
    startDemo,
    pauseDemo,
    resumeDemo,
    stopDemo,
    nextScene,
    prevScene,
    jumpToScene,
    togglePresentationMode,
    makeDecision,
    setPersona,
    setIndustry,
    setExecutiveStep,
    currentSceneData,
    allScenes
  };

  return (
    <DemoControllerContext.Provider value={value}>
      {children}
    </DemoControllerContext.Provider>
  );
}


========================================
FILE: client/src/contexts/DemoTimelineContext.tsx
========================================
import { createContext, useContext, useState, useCallback, useRef, useEffect, useMemo, type ReactNode } from 'react';

export interface DemoTimelineState {
  elapsedMs: number;
  elapsedSeconds: number;
  isRunning: boolean;
  isPaused: boolean;
  isComplete: boolean;
  progress: number;
  formattedTime: string;
  currentPhase: string;
  speedMultiplier: number;
}

export interface TimelineEvent {
  time: number;
  id: string;
  callback?: () => void;
}

interface DemoTimelineContextType {
  state: DemoTimelineState;
  start: (config?: { duration?: number; speedMultiplier?: number }) => void;
  pause: () => void;
  resume: () => void;
  reset: () => void;
  jumpTo: (ms: number) => void;
  setPhase: (phase: string) => void;
  setSpeedMultiplier: (multiplier: number) => void;
  registerEvent: (event: TimelineEvent) => void;
  unregisterEvent: (eventId: string) => void;
  subscribe: (callback: (state: DemoTimelineState) => void) => () => void;
}

const DemoTimelineContext = createContext<DemoTimelineContextType | null>(null);

export function useDemoTimelineContext() {
  const context = useContext(DemoTimelineContext);
  if (!context) {
    throw new Error('useDemoTimelineContext must be used within a DemoTimelineProvider');
  }
  return context;
}

export function useTimelineSafe() {
  return useContext(DemoTimelineContext);
}

export function useTimelineState() {
  const context = useContext(DemoTimelineContext);
  return context?.state ?? {
    elapsedMs: 0,
    elapsedSeconds: 0,
    isRunning: false,
    isPaused: false,
    isComplete: false,
    progress: 0,
    formattedTime: '00:00',
    currentPhase: 'intro',
    speedMultiplier: 20
  };
}

let isTimelineStarted = false;

export function useTimelineOrchestrator() {
  const context = useContext(DemoTimelineContext);
  
  const startOnce = useCallback((config?: { duration?: number; speedMultiplier?: number }) => {
    if (!context) return;
    if (isTimelineStarted && (context.state.isRunning || context.state.elapsedMs > 0)) {
      return;
    }
    isTimelineStarted = true;
    context.start(config);
  }, [context]);
  
  const resetAll = useCallback(() => {
    if (!context) return;
    isTimelineStarted = false;
    context.reset();
  }, [context]);
  
  return {
    startOnce,
    resetAll,
    pause: context?.pause ?? (() => {}),
    resume: context?.resume ?? (() => {})
  };
}

interface DemoTimelineProviderProps {
  children: React.ReactNode;
  defaultDuration?: number;
  defaultSpeedMultiplier?: number;
}

export function DemoTimelineProvider({ 
  children, 
  defaultDuration = 720000,
  defaultSpeedMultiplier = 12
}: DemoTimelineProviderProps) {
  const [elapsedMs, setElapsedMs] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [isComplete, setIsComplete] = useState(false);
  const [currentPhase, setCurrentPhase] = useState('intro');
  const [duration, setDuration] = useState(defaultDuration);
  const [speedMultiplier, setSpeedMultiplierState] = useState(defaultSpeedMultiplier);

  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const lastTickRef = useRef<number>(0);
  const eventsRef = useRef<Map<string, TimelineEvent>>(new Map());
  const firedEventsRef = useRef<Set<string>>(new Set());
  const subscribersRef = useRef<Set<(state: DemoTimelineState) => void>>(new Set());

  const clearTimer = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  const notifySubscribers = useCallback((state: DemoTimelineState) => {
    subscribersRef.current.forEach(callback => callback(state));
  }, []);

  const checkAndFireEvents = useCallback((currentMs: number) => {
    eventsRef.current.forEach((event, eventId) => {
      if (currentMs >= event.time && !firedEventsRef.current.has(eventId)) {
        firedEventsRef.current.add(eventId);
        event.callback?.();
      }
    });
  }, []);

  const start = useCallback((config?: { duration?: number; speedMultiplier?: number }) => {
    clearTimer();
    
    if (config?.duration) setDuration(config.duration);
    if (config?.speedMultiplier) setSpeedMultiplierState(config.speedMultiplier);
    
    const activeDuration = config?.duration || duration;
    const activeSpeed = config?.speedMultiplier || speedMultiplier;
    
    setElapsedMs(0);
    setIsRunning(true);
    setIsPaused(false);
    setIsComplete(false);
    firedEventsRef.current.clear();
    lastTickRef.current = performance.now();

    intervalRef.current = setInterval(() => {
      const now = performance.now();
      const delta = (now - lastTickRef.current) * activeSpeed;
      lastTickRef.current = now;

      setElapsedMs(prev => {
        const newElapsed = Math.min(prev + delta, activeDuration);
        
        checkAndFireEvents(newElapsed);

        if (newElapsed >= activeDuration) {
          clearTimer();
          setIsRunning(false);
          setIsComplete(true);
        }

        return newElapsed;
      });
    }, 50);
  }, [duration, speedMultiplier, clearTimer, checkAndFireEvents]);

  const pause = useCallback(() => {
    clearTimer();
    setIsPaused(true);
    setIsRunning(false);
  }, [clearTimer]);

  const resume = useCallback(() => {
    if (!isPaused || isComplete) return;

    setIsPaused(false);
    setIsRunning(true);
    lastTickRef.current = performance.now();

    intervalRef.current = setInterval(() => {
      const now = performance.now();
      const delta = (now - lastTickRef.current) * speedMultiplier;
      lastTickRef.current = now;

      setElapsedMs(prev => {
        const newElapsed = Math.min(prev + delta, duration);
        
        checkAndFireEvents(newElapsed);

        if (newElapsed >= duration) {
          clearTimer();
          setIsRunning(false);
          setIsComplete(true);
        }

        return newElapsed;
      });
    }, 50);
  }, [isPaused, isComplete, duration, speedMultiplier, clearTimer, checkAndFireEvents]);

  const reset = useCallback(() => {
    clearTimer();
    setElapsedMs(0);
    setIsRunning(false);
    setIsPaused(false);
    setIsComplete(false);
    setCurrentPhase('intro');
    firedEventsRef.current.clear();
  }, [clearTimer]);

  const jumpTo = useCallback((ms: number) => {
    const clampedMs = Math.min(Math.max(0, ms), duration);
    setElapsedMs(clampedMs);

    firedEventsRef.current.clear();
    eventsRef.current.forEach((event, eventId) => {
      if (event.time <= clampedMs) {
        firedEventsRef.current.add(eventId);
      }
    });

    if (clampedMs >= duration) {
      setIsComplete(true);
      setIsRunning(false);
    }
  }, [duration]);

  const setPhase = useCallback((phase: string) => {
    setCurrentPhase(phase);
  }, []);

  const setSpeedMultiplier = useCallback((multiplier: number) => {
    setSpeedMultiplierState(multiplier);
  }, []);

  const registerEvent = useCallback((event: TimelineEvent) => {
    eventsRef.current.set(event.id, event);
    
    if (elapsedMs >= event.time && !firedEventsRef.current.has(event.id)) {
      firedEventsRef.current.add(event.id);
      event.callback?.();
    }
  }, [elapsedMs]);

  const unregisterEvent = useCallback((eventId: string) => {
    eventsRef.current.delete(eventId);
    firedEventsRef.current.delete(eventId);
  }, []);

  const subscribe = useCallback((callback: (state: DemoTimelineState) => void) => {
    subscribersRef.current.add(callback);
    return () => {
      subscribersRef.current.delete(callback);
    };
  }, []);

  useEffect(() => {
    return clearTimer;
  }, [clearTimer]);

  const state = useMemo((): DemoTimelineState => {
    const elapsedSeconds = Math.floor(elapsedMs / 1000);
    const mins = Math.floor(elapsedSeconds / 60);
    const secs = elapsedSeconds % 60;

    return {
      elapsedMs,
      elapsedSeconds,
      isRunning,
      isPaused,
      isComplete,
      progress: duration > 0 ? (elapsedMs / duration) * 100 : 0,
      formattedTime: `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`,
      currentPhase,
      speedMultiplier
    };
  }, [elapsedMs, isRunning, isPaused, isComplete, duration, currentPhase, speedMultiplier]);

  useEffect(() => {
    notifySubscribers(state);
  }, [state, notifySubscribers]);

  const value = useMemo(() => ({
    state,
    start,
    pause,
    resume,
    reset,
    jumpTo,
    setPhase,
    setSpeedMultiplier,
    registerEvent,
    unregisterEvent,
    subscribe
  }), [state, start, pause, resume, reset, jumpTo, setPhase, setSpeedMultiplier, registerEvent, unregisterEvent, subscribe]);

  return (
    <DemoTimelineContext.Provider value={value}>
      {children}
    </DemoTimelineContext.Provider>
  );
}


========================================
FILE: client/src/contexts/DynamicStrategyContext.tsx
========================================
import { createContext, useContext, ReactNode } from 'react';
import { useQuery } from '@tanstack/react-query';

interface ReadinessMetrics {
  overall: number;
  foresight: number;
  velocity: number;
  agility: number;
  learning: number;
  adaptability: number;
}

interface WeakSignal {
  id: string;
  title: string;
  source: string;
  confidence: number;
  category: string;
  timestamp: Date;
}

interface OraclePattern {
  id: string;
  name: string;
  accuracy: number;
  signals: number;
  trend: string;
}

interface ActiveScenario {
  id: string;
  name: string;
  progress: number;
  teamsInvolved: number;
  status: 'active' | 'completed' | 'pending';
}

interface ContinuousMode {
  enabled: boolean;
  tasksScheduled: number;
  nextRun: Date | null;
}

interface DynamicStrategyState {
  readiness: ReadinessMetrics;
  weakSignals: WeakSignal[];
  oraclePatterns: OraclePattern[];
  activeScenarios: ActiveScenario[];
  continuousMode: ContinuousMode;
  teamsCoordinating: number;
  percentOnTrack: number;
  isLoading: boolean;
}

const DynamicStrategyContext = createContext<DynamicStrategyState | null>(null);

export function DynamicStrategyProvider({ children }: { children: ReactNode }) {
  const { data: statusData, isLoading: statusLoading } = useQuery({
    queryKey: ['/api/dynamic-strategy/status'],
    refetchInterval: 5000,
  });

  const { data: readinessData, isLoading: readinessLoading } = useQuery({
    queryKey: ['/api/dynamic-strategy/readiness'],
    refetchInterval: 10000,
  });

  const { data: weakSignalsData, isLoading: signalsLoading } = useQuery({
    queryKey: ['/api/dynamic-strategy/weak-signals'],
    refetchInterval: 15000,
  });

  const { data: patternsData, isLoading: patternsLoading } = useQuery({
    queryKey: ['/api/dynamic-strategy/oracle-patterns'],
    refetchInterval: 30000,
  });

  const isLoading = statusLoading || readinessLoading || signalsLoading || patternsLoading;

  const status = statusData?.status || {
    activeScenarios: 0,
    weakSignals: 0,
    oraclePatterns: 0,
    continuousMode: { enabled: false, tasksScheduled: 0 },
    teamsCoordinating: 0,
    percentOnTrack: 0,
  };

  const readiness: ReadinessMetrics = readinessData?.readiness || {
    overall: 0,
    foresight: 0,
    velocity: 0,
    agility: 0,
    learning: 0,
    adaptability: 0,
  };

  const weakSignals: WeakSignal[] = (weakSignalsData?.signals || []).map((s: any) => ({
    id: s.id,
    title: s.title,
    source: s.source,
    confidence: s.confidence,
    category: s.category,
    timestamp: new Date(s.timestamp),
  }));

  const oraclePatterns: OraclePattern[] = (patternsData?.patterns || []).map((p: any) => ({
    id: p.id,
    name: p.name,
    accuracy: p.accuracy,
    signals: p.signals_count,
    trend: p.trend,
  }));

  const activeScenarios: ActiveScenario[] = [
    {
      id: '1',
      name: 'Ransomware Response',
      progress: 65,
      teamsInvolved: 8,
      status: 'active',
    },
    {
      id: '2',
      name: 'M&A Integration',
      progress: 42,
      teamsInvolved: 12,
      status: 'active',
    },
    {
      id: '3',
      name: 'Supply Chain Disruption',
      progress: 88,
      teamsInvolved: 6,
      status: 'active',
    },
  ];

  const continuousMode: ContinuousMode = {
    enabled: status.continuousMode.enabled,
    tasksScheduled: status.continuousMode.tasksScheduled,
    nextRun: status.continuousMode.nextRun ? new Date(status.continuousMode.nextRun) : null,
  };

  const state: DynamicStrategyState = {
    readiness,
    weakSignals,
    oraclePatterns,
    activeScenarios,
    continuousMode,
    teamsCoordinating: status.teamsCoordinating || activeScenarios.reduce((sum, s) => sum + s.teamsInvolved, 0),
    percentOnTrack: status.percentOnTrack || Math.round(activeScenarios.reduce((sum, s) => sum + s.progress, 0) / activeScenarios.length),
    isLoading,
  };

  return (
    <DynamicStrategyContext.Provider value={state}>
      {children}
    </DynamicStrategyContext.Provider>
  );
}

export function useDynamicStrategy() {
  const context = useContext(DynamicStrategyContext);
  if (!context) {
    throw new Error('useDynamicStrategy must be used within DynamicStrategyProvider');
  }
  return context;
}


========================================
FILE: client/src/contexts/OnboardingContext.tsx
========================================
import { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';

interface OnboardingStep {
  id: string;
  title: string;
  description: string;
  targetElement?: string;
  position?: 'top' | 'bottom' | 'left' | 'right';
  phase?: 'IDENTIFY' | 'DETECT' | 'EXECUTE' | 'ADVANCE';
}

interface PageOnboarding {
  pageId: string;
  pageName: string;
  steps: OnboardingStep[];
}

interface OnboardingState {
  hasSeenOnboarding: Record<string, boolean>;
  currentPage: string | null;
  currentStep: number;
  isActive: boolean;
}

interface OnboardingContextType {
  state: OnboardingState;
  startOnboarding: (pageId: string) => void;
  nextStep: () => void;
  prevStep: () => void;
  skipOnboarding: () => void;
  dismissOnboarding: () => void;
  resetOnboarding: (pageId?: string) => void;
  getCurrentPageSteps: () => OnboardingStep[];
  getCurrentStep: () => OnboardingStep | null;
  isPageOnboarded: (pageId: string) => boolean;
}

const OnboardingContext = createContext<OnboardingContextType | null>(null);

const ONBOARDING_STORAGE_KEY = 'm-onboarding-state';

export const pageOnboardingConfigs: Record<string, PageOnboarding> = {
  'command-center': {
    pageId: 'command-center',
    pageName: 'Command Center',
    steps: [
      {
        id: 'cc-welcome',
        title: 'Welcome to Command Center',
        description: 'This is your real-time strategic execution hub. Monitor active scenarios, coordinate teams, and track execution progress across your organization.',
        phase: 'EXECUTE'
      },
      {
        id: 'cc-active-scenarios',
        title: 'Active Scenarios',
        description: 'View all currently active strategic scenarios. Each card shows team coordination status, progress percentage, and allows drill-down to details.',
        targetElement: 'button-launch-scenario',
        position: 'bottom',
        phase: 'EXECUTE'
      },
      {
        id: 'cc-readiness-index',
        title: 'Future Readiness Indexâ„¢',
        description: 'Your organization\'s preparedness score across 5 dimensions: Foresight, Velocity, Agility, Learning, and Adaptability. Target: 84.4%',
        phase: 'IDENTIFY'
      },
      {
        id: 'cc-weak-signals',
        title: 'Weak Signals Detection',
        description: 'AI continuously monitors 12 intelligence sources for early warning indicators. Higher confidence signals may trigger playbook recommendations.',
        phase: 'DETECT'
      },
      {
        id: 'cc-oracle',
        title: 'Oracle Intelligence',
        description: 'Pattern recognition across market, competitive, and operational data. These patterns inform proactive strategy adjustments.',
        phase: 'DETECT'
      }
    ]
  },
  'executive-scorecard': {
    pageId: 'executive-scorecard',
    pageName: 'Executive Scorecard',
    steps: [
      {
        id: 'es-welcome',
        title: 'Your Executive Scorecard',
        description: 'Track your strategic execution performance with key metrics. This dashboard shows your ROI, time savings, and execution velocity.',
        phase: 'ADVANCE'
      },
      {
        id: 'es-roi',
        title: 'ROI & Value Metrics',
        description: '$5.8M annual value comes from faster decisions (48x ROI), reduced coordination time (720 hours saved), and 12-minute execution vs 72-hour industry standard.',
        targetElement: 'card-roi-banner',
        position: 'bottom',
        phase: 'ADVANCE'
      },
      {
        id: 'es-velocity',
        title: 'Execution Velocity',
        description: 'M compresses 72-hour coordination into 12-minute execution. Track your performance against this benchmark.',
        phase: 'EXECUTE'
      }
    ]
  },
  'what-if-analyzer': {
    pageId: 'what-if-analyzer',
    pageName: 'What-If Analyzer',
    steps: [
      {
        id: 'wia-welcome',
        title: 'What-If Analyzer',
        description: 'Model any business scenario beyond the 166 playbook templates. Test market conditions, assess impact, and get AI-powered recommendations.',
        phase: 'IDENTIFY'
      },
      {
        id: 'wia-quick-start',
        title: 'Quick Start Templates',
        description: 'Start with one of 6 popular scenario templates: Product Recall, Supply Chain, Market Entry, Cyber Incident, M&A Integration, or Regulatory Change.',
        targetElement: 'quick-start-templates',
        position: 'bottom',
        phase: 'IDENTIFY'
      },
      {
        id: 'wia-custom',
        title: 'Custom Scenarios',
        description: 'Build unlimited custom scenarios. Define conditions, assess impact, allocate resources, and receive AI playbook recommendations.',
        phase: 'IDENTIFY'
      }
    ]
  },
  'scenario-gallery': {
    pageId: 'scenario-gallery',
    pageName: 'Scenario Gallery',
    steps: [
      {
        id: 'sg-welcome',
        title: '166 Strategic Playbooks',
        description: 'Browse 166 battle-tested playbooks across 9 strategic domains. Each playbook includes pre-mapped stakeholders, decision trees, and communication templates.',
        phase: 'IDENTIFY'
      },
      {
        id: 'sg-domains',
        title: '9 Strategic Domains',
        description: 'Playbooks are organized into domains: Market Response, Operational Resilience, People & Culture, Technology & Innovation, Regulatory Compliance, Crisis Management, Growth & Expansion, Strategic Partnerships, and AI Governance.',
        phase: 'IDENTIFY'
      },
      {
        id: 'sg-unlimited',
        title: 'Unlimited Custom Scenarios',
        description: 'Use the What-If Analyzer to create unlimited custom scenarios beyond the 166 templates. Every scenario becomes a living playbook that improves over time.',
        phase: 'IDENTIFY'
      }
    ]
  },
  'playbook-readiness': {
    pageId: 'playbook-readiness',
    pageName: 'Playbook Readiness Audit',
    steps: [
      {
        id: 'pr-welcome',
        title: 'Playbook Readiness Audit',
        description: 'Assess the preparedness of your 166 playbooks across 4 key dimensions: Trigger Coverage, Stakeholder Readiness, Practice Frequency, and Outcome Confidence.',
        phase: 'IDENTIFY'
      },
      {
        id: 'pr-quadrant',
        title: 'Readiness Quadrant',
        description: 'Playbooks are categorized into 4 tiers: Combat Ready (80%+), Practice Needed (60-79%), Setup Required (40-59%), and Not Configured (<40%).',
        phase: 'IDENTIFY'
      },
      {
        id: 'pr-actions',
        title: 'Improvement Actions',
        description: 'Each playbook includes specific actions to improve readiness: schedule drills, update stakeholders, configure triggers, or review decision trees.',
        phase: 'ADVANCE'
      }
    ]
  },
  'triggers-management': {
    pageId: 'triggers-management',
    pageName: 'Executive Trigger Dashboard',
    steps: [
      {
        id: 'tm-welcome',
        title: 'Executive Trigger Dashboard',
        description: 'This is where YOU define what matters. Set up trigger conditions that AI monitors 24/7, automatically activating playbooks when your thresholds are breached.',
        phase: 'DETECT'
      },
      {
        id: 'tm-categories',
        title: '16 Intelligence Categories',
        description: 'Monitor 92+ data points across categories: Competitive, Market, Financial, Regulatory, Supply Chain, Customer, Talent, Technology, Cyber, and more.',
        phase: 'DETECT'
      },
      {
        id: 'tm-conditions',
        title: 'Trigger Conditions',
        description: 'Each trigger shows its field, operator, threshold value, and logic. When conditions are met, the system automatically recommends or activates the right playbook.',
        phase: 'EXECUTE'
      },
      {
        id: 'tm-notifications',
        title: 'Notification Settings',
        description: 'Configure how you want to be alerted: Email, In-App, Slack, or full Escalation workflows with approval chains.',
        phase: 'EXECUTE'
      }
    ]
  },
  'ai-radar': {
    pageId: 'ai-radar',
    pageName: 'AI Radar',
    steps: [
      {
        id: 'ar-welcome',
        title: 'AI Radar - Live Intelligence',
        description: 'Your real-time strategic intelligence hub. AI continuously scans 12 signal sources to detect weak signals, emerging patterns, and potential threats before they materialize.',
        phase: 'DETECT'
      },
      {
        id: 'ar-signals',
        title: 'Signal Detection',
        description: 'Watch for weak signals across market, competitive, regulatory, and operational domains. Higher confidence signals may trigger automatic playbook recommendations.',
        phase: 'DETECT'
      },
      {
        id: 'ar-patterns',
        title: 'Pattern Recognition',
        description: 'The Oracle engine identifies patterns across multiple data sources, helping you spot opportunities and threats that would otherwise go unnoticed.',
        phase: 'DETECT'
      }
    ]
  },
  'pulse-intelligence': {
    pageId: 'pulse-intelligence',
    pageName: 'Pulse Intelligence',
    steps: [
      {
        id: 'pi-welcome',
        title: 'Pulse Intelligence',
        description: 'Real-time market pulse monitoring. Track sentiment, news flow, social signals, and market movements that could impact your strategic position.',
        phase: 'DETECT'
      },
      {
        id: 'pi-feeds',
        title: 'Live Data Feeds',
        description: 'Aggregated intelligence from news sources, social media, analyst reports, and market data providers - all analyzed in real-time.',
        phase: 'DETECT'
      }
    ]
  },
  'flux-adaptations': {
    pageId: 'flux-adaptations',
    pageName: 'Flux Adaptations',
    steps: [
      {
        id: 'fa-welcome',
        title: 'Flux Adaptations',
        description: 'Track how your organization adapts to changing conditions. Monitor change velocity, adaptation patterns, and organizational agility metrics.',
        phase: 'ADVANCE'
      },
      {
        id: 'fa-velocity',
        title: 'Adaptation Velocity',
        description: 'Measure how quickly your teams respond to strategic shifts. Identify bottlenecks and accelerate your change capability.',
        phase: 'ADVANCE'
      }
    ]
  },
  'prism-insights': {
    pageId: 'prism-insights',
    pageName: 'Prism Insights',
    steps: [
      {
        id: 'pri-welcome',
        title: 'Prism Insights',
        description: 'Multi-dimensional analysis of your strategic landscape. View opportunities and threats through different lenses - financial, operational, competitive, and stakeholder perspectives.',
        phase: 'DETECT'
      },
      {
        id: 'pri-lenses',
        title: 'Strategic Lenses',
        description: 'Each lens reveals different aspects of the same situation, helping you make more balanced decisions with full context.',
        phase: 'IDENTIFY'
      }
    ]
  },
  'echo-cultural': {
    pageId: 'echo-cultural',
    pageName: 'Echo Cultural Analytics',
    steps: [
      {
        id: 'ec-welcome',
        title: 'Echo Cultural Analytics',
        description: 'Monitor organizational culture and sentiment. Track employee engagement, cultural alignment, and the human side of strategic execution.',
        phase: 'ADVANCE'
      },
      {
        id: 'ec-sentiment',
        title: 'Sentiment Analysis',
        description: 'AI analyzes communication patterns, feedback, and engagement signals to surface cultural health indicators.',
        phase: 'DETECT'
      }
    ]
  },
  'nova-innovations': {
    pageId: 'nova-innovations',
    pageName: 'Nova Innovations',
    steps: [
      {
        id: 'ni-welcome',
        title: 'Nova Innovations',
        description: 'Track your innovation pipeline and emerging opportunities. Monitor R&D progress, competitive innovations, and market disruption signals.',
        phase: 'DETECT'
      },
      {
        id: 'ni-pipeline',
        title: 'Innovation Pipeline',
        description: 'Visualize initiatives from ideation through execution. Identify stalled projects and accelerate high-potential innovations.',
        phase: 'IDENTIFY'
      }
    ]
  }
};

export function OnboardingProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<OnboardingState>(() => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem(ONBOARDING_STORAGE_KEY);
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          return {
            ...parsed,
            currentPage: null,
            currentStep: 0,
            isActive: false
          };
        } catch {
          // Invalid saved state
        }
      }
    }
    return {
      hasSeenOnboarding: {},
      currentPage: null,
      currentStep: 0,
      isActive: false
    };
  });

  useEffect(() => {
    localStorage.setItem(ONBOARDING_STORAGE_KEY, JSON.stringify({
      hasSeenOnboarding: state.hasSeenOnboarding
    }));
  }, [state.hasSeenOnboarding]);

  const startOnboarding = useCallback((pageId: string) => {
    if (pageOnboardingConfigs[pageId]) {
      setState(prev => ({
        ...prev,
        currentPage: pageId,
        currentStep: 0,
        isActive: true
      }));
    }
  }, []);

  const nextStep = useCallback(() => {
    setState(prev => {
      if (!prev.currentPage) return prev;
      const config = pageOnboardingConfigs[prev.currentPage];
      if (!config) return prev;

      if (prev.currentStep >= config.steps.length - 1) {
        return {
          ...prev,
          hasSeenOnboarding: { ...prev.hasSeenOnboarding, [prev.currentPage]: true },
          currentPage: null,
          currentStep: 0,
          isActive: false
        };
      }

      return {
        ...prev,
        currentStep: prev.currentStep + 1
      };
    });
  }, []);

  const prevStep = useCallback(() => {
    setState(prev => ({
      ...prev,
      currentStep: Math.max(0, prev.currentStep - 1)
    }));
  }, []);

  const skipOnboarding = useCallback(() => {
    setState(prev => {
      if (!prev.currentPage) return prev;
      return {
        ...prev,
        hasSeenOnboarding: { ...prev.hasSeenOnboarding, [prev.currentPage]: true },
        currentPage: null,
        currentStep: 0,
        isActive: false
      };
    });
  }, []);

  const dismissOnboarding = useCallback(() => {
    setState(prev => ({
      ...prev,
      currentPage: null,
      currentStep: 0,
      isActive: false
    }));
  }, []);

  const resetOnboarding = useCallback((pageId?: string) => {
    setState(prev => {
      if (pageId) {
        const { [pageId]: _, ...rest } = prev.hasSeenOnboarding;
        return { ...prev, hasSeenOnboarding: rest };
      }
      return { ...prev, hasSeenOnboarding: {} };
    });
  }, []);

  const getCurrentPageSteps = useCallback(() => {
    if (!state.currentPage) return [];
    return pageOnboardingConfigs[state.currentPage]?.steps || [];
  }, [state.currentPage]);

  const getCurrentStep = useCallback(() => {
    const steps = getCurrentPageSteps();
    return steps[state.currentStep] || null;
  }, [getCurrentPageSteps, state.currentStep]);

  const isPageOnboarded = useCallback((pageId: string) => {
    return state.hasSeenOnboarding[pageId] === true;
  }, [state.hasSeenOnboarding]);

  return (
    <OnboardingContext.Provider value={{
      state,
      startOnboarding,
      nextStep,
      prevStep,
      skipOnboarding,
      dismissOnboarding,
      resetOnboarding,
      getCurrentPageSteps,
      getCurrentStep,
      isPageOnboarded
    }}>
      {children}
    </OnboardingContext.Provider>
  );
}

export function useOnboarding() {
  const context = useContext(OnboardingContext);
  if (!context) {
    throw new Error('useOnboarding must be used within an OnboardingProvider');
  }
  return context;
}


========================================
FILE: client/src/services/dynamicStrategySimulator.ts
========================================
import { queryClient } from '@/lib/queryClient';

interface ReadinessMetrics {
  foresight: number;
  velocity: number;
  agility: number;
  learning: number;
  adaptability: number;
}

interface WeakSignal {
  type: string;
  confidence: number;
  timeline: string;
  impact: string;
  timestamp: Date;
  id: string;
}

interface OraclePattern {
  type: string;
  confidence: number;
  impact: string;
  timeline: string;
  recommendations: string[];
}

interface ActiveScenario {
  id: string;
  name: string;
  description: string;
  startTime: Date;
  status: 'active' | 'completed';
  progress: number;
  duration?: string;
  success?: boolean;
}

interface ContinuousMode {
  enabled: boolean;
  schedule: Record<string, {
    task: string;
    duration: number;
    status: 'completed' | 'pending' | 'scheduled';
  }>;
  metrics: {
    patternsDetected: number;
    playbooksUpdated: number;
    teamReadiness: number;
  };
}

class DynamicStrategySimulator {
  private readinessScore: number = 84.4;
  private metrics: ReadinessMetrics = {
    foresight: 82,
    velocity: 94,
    agility: 87,
    learning: 73,
    adaptability: 85
  };
  private activeScenarios: Map<string, {scenario: ActiveScenario, interval: NodeJS.Timeout}> = new Map();
  private weakSignals: WeakSignal[] = [];
  private oraclePatterns: OraclePattern[] = [];
  private continuousMode: ContinuousMode | null = null;
  private realTimeInterval: NodeJS.Timeout | null = null;
  private patternInterval: NodeJS.Timeout | null = null;
  private activityInterval: NodeJS.Timeout | null = null;
  private isRunning: boolean = false;

  start() {
    if (this.isRunning) return;
    
    console.log('ðŸš€ M Dynamic Strategy Simulator: STARTING');
    this.isRunning = true;
    this.startRealTimeUpdates();
    this.initializeOracle();
    this.enableContinuousMode();
  }

  stop() {
    console.log('â¸ï¸ M Dynamic Strategy Simulator: STOPPING');
    this.isRunning = false;
    
    if (this.realTimeInterval) clearInterval(this.realTimeInterval);
    if (this.patternInterval) clearInterval(this.patternInterval);
    if (this.activityInterval) clearInterval(this.activityInterval);
  }

  private startRealTimeUpdates() {
    this.realTimeInterval = setInterval(() => {
      this.updateReadinessScore();
      this.detectWeakSignals();
      this.updateActivityFeed();
    }, 5000);
  }

  private updateReadinessScore() {
    const variance = (Math.random() * 2 - 1) * 0.5;
    this.readinessScore = Math.max(70, Math.min(95, this.readinessScore + variance));
    
    Object.keys(this.metrics).forEach(key => {
      const change = (Math.random() * 2 - 1) * 2;
      this.metrics[key as keyof ReadinessMetrics] = Math.max(60, Math.min(100, this.metrics[key as keyof ReadinessMetrics] + change));
    });

    this.invalidateQueries();
  }

  private detectWeakSignals() {
    const signalTypes = [
      { type: 'regulatory', confidence: 73, timeline: '3-6 months', impact: 'high' },
      { type: 'competitor', confidence: 61, timeline: '1-2 months', impact: 'medium' },
      { type: 'technology', confidence: 85, timeline: '6-12 months', impact: 'high' },
      { type: 'market', confidence: 67, timeline: '2-4 weeks', impact: 'low' },
      { type: 'supply chain', confidence: 79, timeline: '1-3 months', impact: 'critical' }
    ];

    if (Math.random() > 0.7) {
      const signalTemplate = signalTypes[Math.floor(Math.random() * signalTypes.length)];
      const signal: WeakSignal = {
        ...signalTemplate,
        timestamp: new Date(),
        id: Math.random().toString(36).substr(2, 9)
      };
      
      this.weakSignals.push(signal);
      this.alertNewSignal(signal);
      this.invalidateQueries();
    }
  }

  private alertNewSignal(signal: WeakSignal) {
    console.log(`âš ï¸ New weak signal detected: ${signal.type} (${signal.confidence}% confidence)`);
    
    this.logActivity({
      eventType: 'weak_signal_detected',
      title: `Weak Signal: ${signal.type}`,
      description: `${signal.confidence}% confidence, ${signal.timeline} timeline`,
      severity: signal.impact === 'critical' ? 'critical' : signal.impact === 'high' ? 'high' : 'medium'
    });
  }

  private initializeOracle() {
    this.patternInterval = setInterval(() => {
      this.detectPatterns();
    }, 30000);
  }

  private detectPatterns() {
    const patterns: OraclePattern[] = [
      {
        type: 'Regulatory shift',
        confidence: Math.floor(60 + Math.random() * 30),
        impact: ['high', 'medium', 'critical'][Math.floor(Math.random() * 3)],
        timeline: ['1-3 months', '3-6 months', '6-12 months'][Math.floor(Math.random() * 3)],
        recommendations: [
          'Pre-load compliance playbook',
          'Schedule legal briefing',
          'Run simulation exercise'
        ]
      },
      {
        type: 'Market disruption',
        confidence: Math.floor(50 + Math.random() * 40),
        impact: ['high', 'medium', 'low'][Math.floor(Math.random() * 3)],
        timeline: ['2-4 weeks', '1-2 months', '2-3 months'][Math.floor(Math.random() * 3)],
        recommendations: [
          'Review competitor responses',
          'Update pricing strategy',
          'Prepare customer communications'
        ]
      },
      {
        type: 'Supply chain risk',
        confidence: Math.floor(70 + Math.random() * 25),
        impact: 'critical',
        timeline: '1-4 weeks',
        recommendations: [
          'Identify alternate suppliers',
          'Increase inventory buffers',
          'Alert operations teams'
        ]
      }
    ];

    if (Math.random() > 0.6) {
      const pattern = patterns[Math.floor(Math.random() * patterns.length)];
      this.oraclePatterns.push(pattern);
      this.alertPattern(pattern);
      this.invalidateQueries();
    }
  }

  private alertPattern(pattern: OraclePattern) {
    console.log(`ðŸ”® M Oracle: ${pattern.type} detected (${pattern.confidence}% confidence)`);
    
    this.logActivity({
      eventType: 'oracle_pattern_detected',
      title: `Oracle Pattern: ${pattern.type}`,
      description: `${pattern.confidence}% confidence, impact: ${pattern.impact}`,
      severity: pattern.impact === 'critical' ? 'critical' : 'high'
    });
  }

  private enableContinuousMode() {
    this.continuousMode = {
      enabled: true,
      schedule: {
        monday: { task: 'Weak Signal Scan', duration: 15, status: 'completed' },
        tuesday: { task: 'Scenario Refresh', duration: 30, status: 'completed' },
        wednesday: { task: 'Team Drill', duration: 12, status: 'pending' },
        thursday: { task: 'Playbook Evolution', duration: 45, status: 'scheduled' },
        friday: { task: 'Readiness Review', duration: 20, status: 'scheduled' }
      },
      metrics: {
        patternsDetected: 3,
        playbooksUpdated: 2,
        teamReadiness: 91
      }
    };

    console.log('âœ… Continuous Operations Mode: ACTIVE');
  }

  launchScenario(scenarioId: string, scenarioName: string) {
    const activeScenario: ActiveScenario = {
      id: scenarioId,
      name: scenarioName,
      description: `Simulating ${scenarioName} execution`,
      startTime: new Date(),
      status: 'active',
      progress: 0
    };

    const interval = this.startScenarioCoordination(activeScenario);
    this.activeScenarios.set(scenarioId, { scenario: activeScenario, interval });
    
    this.logActivity({
      eventType: 'scenario_launched',
      title: `Scenario Activated: ${scenarioName}`,
      description: 'Coordinated response initiated',
      severity: 'info'
    });
  }

  private startScenarioCoordination(scenario: ActiveScenario): NodeJS.Timeout {
    console.log(`ðŸš€ Launching ${scenario.name} coordination...`);
    
    const interval = setInterval(() => {
      scenario.progress += 10;
      
      if (scenario.progress >= 100) {
        clearInterval(interval);
        this.completeScenario(scenario);
      } else {
        this.invalidateQueries();
      }
    }, 1000);
    
    return interval;
  }

  private completeScenario(scenario: ActiveScenario) {
    const endTime = new Date();
    const duration = (endTime.getTime() - scenario.startTime.getTime()) / 60000;
    
    scenario.status = 'completed';
    scenario.duration = duration.toFixed(1);
    scenario.success = duration <= 12;

    console.log(`âœ… Scenario completed in ${scenario.duration} minutes`);
    
    this.logActivity({
      eventType: 'scenario_completed',
      title: `Scenario Completed: ${scenario.name}`,
      description: `Finished in ${scenario.duration} minutes - ${scenario.success ? 'SUCCESS' : 'LEARNING OPPORTUNITY'}`,
      severity: scenario.success ? 'success' : 'warning'
    });

    this.invalidateQueries();
  }

  private updateActivityFeed() {
    const activities = [
      { type: 'pattern_detected', text: 'Pattern detected: Unusual network activity', severity: 'warning' },
      { type: 'playbook_updated', text: 'Playbook updated: Regulatory Response v2.3', severity: 'info' },
      { type: 'drill_completed', text: 'Team drill completed: 13.2 minutes', severity: 'success' },
      { type: 'weak_signal', text: 'Weak signal: Competitor announcement detected', severity: 'medium' },
      { type: 'oracle_prediction', text: 'AI Oracle: New regulatory risk identified', severity: 'high' },
      { type: 'scenario_launched', text: 'Scenario launched: Supply chain exercise', severity: 'info' },
      { type: 'learning_integrated', text: 'Learning integrated: Response time improved', severity: 'success' },
      { type: 'alert', text: 'Alert: Stakeholder availability confirmed', severity: 'info' }
    ];

    if (Math.random() > 0.6) {
      const activity = activities[Math.floor(Math.random() * activities.length)];
      this.logActivity({
        eventType: activity.type,
        title: activity.text,
        description: `Automated system update - ${new Date().toLocaleTimeString()}`,
        severity: activity.severity as any
      });
    }
  }

  private logActivity(activity: {
    eventType: string;
    title: string;
    description: string;
    severity: string;
  }) {
    const timestamp = new Date().toLocaleTimeString();
    console.log(`[${timestamp}] ${activity.title}`);
    
    queryClient.invalidateQueries({ queryKey: ['/api/dynamic-strategy/activity-feed'] });
  }

  private invalidateQueries() {
    queryClient.invalidateQueries({ queryKey: ['/api/dynamic-strategy/status'] });
    queryClient.invalidateQueries({ queryKey: ['/api/dynamic-strategy/readiness'] });
    queryClient.invalidateQueries({ queryKey: ['/api/dynamic-strategy/weak-signals'] });
    queryClient.invalidateQueries({ queryKey: ['/api/dynamic-strategy/oracle-patterns'] });
    queryClient.invalidateQueries({ queryKey: ['/api/dynamic-strategy/activity-feed'] });
  }

  getStatus() {
    return {
      isRunning: this.isRunning,
      readinessScore: this.readinessScore,
      metrics: this.metrics,
      activeScenarios: this.activeScenarios.size,
      weakSignals: this.weakSignals.length,
      oraclePatterns: this.oraclePatterns.length,
      continuousMode: this.continuousMode?.enabled || false
    };
  }
}

export const dynamicStrategySimulator = new DynamicStrategySimulator();




========================================
FILE: shared/constants/taskLibrary.ts (Task Library Types & Helpers)
========================================

// Import pattern for Task Library in components
import { 
  ENTERPRISE_TASK_LIBRARY, 
  TASK_CATEGORIES, 
  IDEA_PHASES,
  type TaskTemplate,
  type TaskCategory,
  type IdeaPhase,
  getTaskLibraryStats,
  getTasksByPhase,
  getTasksByCategory,
  getCriticalTasks,
} from '@shared/constants/taskLibrary';

// Task Template Interface
export interface TaskTemplate {
  id: string;
  title: string;
  description: string;
  suggestedOwner: string;
  estimatedMinutes: number;
  priority: TaskPriority;
  category: TaskCategory;
  phase: IdeaPhase;
  approvalRequired: 'none' | 'manager' | 'director' | 'vp' | 'c_suite' | 'board';
  deliverables: string;
  integrations?: string[];
  slaMinutes?: number;
}

// Convert library template to playbook task format
const templateToTask = (template: TaskTemplate): Task => ({
  id: template.id,
  templateId: template.id, // Preserve for duplicate detection
  title: template.title,
  description: template.description,
  assignedRole: template.suggestedOwner,
  estimatedMinutes: template.estimatedMinutes,
  priority: template.priority,
  status: 'pending',
  dependsOn: [],
  approvalRequired: template.approvalRequired,
  deliverables: template.deliverables,
});

// Duplicate detection using templateId
const addedLibraryIds = useMemo(() => 
  new Set(tasks.map(t => t.templateId).filter(Boolean)), 
  [tasks]
);

